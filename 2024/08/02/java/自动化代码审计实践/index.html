<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mayylu">



    <meta name="description" content="学习是一种生活态度">



<title>自动化代码审计实践 | mayylu&#39;s blog</title>



    <link rel="icon" href="/vue.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">mayylu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">mayylu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">自动化代码审计实践</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mayylu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 2, 2024&nbsp;&nbsp;</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/java/">java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人并不是很喜欢写工具使用教程，但是每次用都得搜语法，再加上之前找实习的时候几乎只要牵涉到Java安全，就会问有没有使用过自动化代码审计工具，所以干脆写一篇语法总结<br> <span id="more"></span></p>
<h2 id="反序列化的节点"><a href="#反序列化的节点" class="headerlink" title="反序列化的节点"></a>反序列化的节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">起点：</span><br><span class="line">readObject</span><br><span class="line">java.lang.reflect.InvocationHandler.invoke</span><br><span class="line">readResolve</span><br><span class="line">readExternal</span><br><span class="line"></span><br><span class="line">终点：</span><br><span class="line">java.lang.reflect.invoke</span><br><span class="line">Class.forName()</span><br><span class="line">loadClass()</span><br><span class="line">defineClass()</span><br><span class="line">lookup()</span><br><span class="line"></span><br><span class="line">常用链：</span><br><span class="line">HashMap.readObject-&gt;HashMap.hash()-&gt;*.hashCode()</span><br><span class="line">Hashtable.readObject-&gt;AbstractMap.equals-&gt;*.get()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="tabby使用"><a href="#tabby使用" class="headerlink" title="tabby使用"></a>tabby使用</h2><p>TABBY是一款针对Java语言的静态代码分析工具。<br>它使用静态分析框架 Soot 作为语义提取工具，将JAR/WAR/CLASS文件转化为代码属性图。 并使用 Neo4j 图数据库来存储生成的代码属性图CPG。</p>
<h3 id="使用前的配置"><a href="#使用前的配置" class="headerlink" title="使用前的配置"></a>使用前的配置</h3><p>怎么安装就不写了,这里只写用法<br>tabby配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tabby.build.target                        = cases/hessian-onlyJdk.jar</span><br><span class="line"># 有些情况需要某些依赖，但是又不想分析这些依赖，此时可以放到lib目录下</span><br><span class="line">tabby.build.libraries                     = libs</span><br><span class="line">tabby.build.mode                          = gadget # 分析类型 web 或 gadget，web模式会剔除常见jar包的全量分析，gadget模式会对target目录下的文件进行全量分析，如果是挖web层面的漏洞可以设置mode为web</span><br><span class="line">tabby.output.directory                    = ./output/dev</span><br><span class="line"></span><br><span class="line"># debug</span><br><span class="line">tabby.debug.details                       = true</span><br><span class="line"></span><br><span class="line"># jdk settings</span><br><span class="line">tabby.build.isJDKProcess                  = true # 分析过程是否加入基础的2个jdk依赖，这里我们主要挖掘target 目录文件的利用链所以设置isJDKProcess为true</span><br><span class="line">tabby.build.withAllJDK                    = false # 分析过程是否加入全量的jdk依赖</span><br><span class="line">tabby.build.excludeJDK                    = false</span><br><span class="line">tabby.build.isJDKOnly                     = false# 分析过程仅分析jdk依赖，不会去分析target目录下的文件,用于挖掘 jdk 里面的利用链</span><br></pre></td></tr></table></figure>
<p>neo4j配置看官方语雀<code>https://www.yuque.com/wh1t3p1g/tp0c1t/wx6fiha89p0wu6s5#</code></p>
<h3 id="多个jar包分析"><a href="#多个jar包分析" class="headerlink" title="多个jar包分析"></a>多个jar包分析</h3><p>如果是多个jar包可以先合成一个</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> folder=E:\code\tabby\cases\weblogic</span><br><span class="line"><span class="comment">rem 设置目标目录</span></span><br><span class="line"><span class="built_in">set</span> targetDir=E:\code\tabby\cases\weblogic\directory</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 创建目标目录，如果它不存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span> &quot;<span class="variable">%targetDir%</span>&quot; <span class="built_in">mkdir</span> &quot;<span class="variable">%targetDir%</span>&quot;</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 切换到目标目录</span></span><br><span class="line"><span class="built_in">cd</span> /d &quot;<span class="variable">%targetDir%</span>&quot;</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 遍历当前目录下所有 .jar 文件</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%F</span> <span class="keyword">in</span> (<span class="variable">%folder%</span>\*.jar) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> 正在解压 <span class="variable">%%F</span>...</span><br><span class="line"><span class="comment">    rem 使用 jar 解压</span></span><br><span class="line">    &quot;E:\Download\java\bin\jar.exe&quot; xf &quot;<span class="variable">%%F</span>&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 解压完成！</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p><code>jar cf merged.jar -C directory_path .</code>将directory_path下的jar包合成一个merged.jar</p>
<h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx7g -jar tabby.jar <span class="comment">#允许命令，7g是分配的内存，不能设置太高了，不然内存爆了还得重新来</span></span><br></pre></td></tr></table></figure>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Cypher 是 Neo4j 的图查询语言，被设计用于查询图数据</p>
<h4 id="漏洞挖掘找可能存在的链子"><a href="#漏洞挖掘找可能存在的链子" class="headerlink" title="漏洞挖掘找可能存在的链子"></a>漏洞挖掘找可能存在的链子</h4><p>这里以hessian反序列化为例，演示的内容为<code>0CTF/TCTF 2022 hessian-onlyJdk</code>的一个非预期<br>我们先找<strong>readobject-&gt;putval</strong>这个已经公认的链子，起始点肯定是<code>com.caucho.hessian.io.Hessian2Input#readObject</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match (source:Method) where source.NAME in [&quot;readObject&quot;] and source.CLASSNAME=&quot;com.caucho.hessian.io.Hessian2Input&quot;</span><br><span class="line">match (sink:Method &#123;IS_SINK:true, NAME:&quot;invoke&quot;&#125;)&lt;-[r:CALL]-(m1:Method) where r.REAL_CALL_TYPE in [&quot;java.lang.reflect.Method&quot;]</span><br><span class="line">CALL apoc.algo.allSimplePaths(m1, source ,&quot;&lt;CALL|ALIAS&quot;, 9) yield path</span><br><span class="line">return * limit 20</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/QQ20240921111-19218552.png" alt="QQ20240921111-19218552"><br>我们再找sink点，这里以任意方法调用为目标(为方便展示，这里只返回一条路径，实践这样的化容易误判)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match (source:Method) where source.NAME in [&quot;putVal&quot;] and source.CLASSNAME=&quot;java.util.HashMap&quot;</span><br><span class="line">match (sink:Method &#123;IS_SINK:true, NAME:&quot;invoke&quot;&#125;)&lt;-[r:CALL]-(m1:Method) where r.REAL_CALL_TYPE in [&quot;java.lang.reflect.Method&quot;]</span><br><span class="line">CALL apoc.algo.allSimplePaths(m1, source ,&quot;&lt;CALL|ALIAS&quot;, 9) yield path</span><br><span class="line">return * limit 1</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/QQ20241001-043900.png" alt="QQ20241001-043900"></p>
<h4 id="ctf比赛找黑名单绕过"><a href="#ctf比赛找黑名单绕过" class="headerlink" title="ctf比赛找黑名单绕过"></a>ctf比赛找黑名单绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match (source:Method) where source.NAME in [&quot;readObject&quot;] and source.CLASSNAME=&quot;javax.activation.URLDataSource&quot;</span><br><span class="line">match (sink:Method &#123;NAME:&quot;toString&quot;&#125;)&lt;-[r:CALL]-(m1:Method) </span><br><span class="line">call apoc.algo.allSimplePaths(m1, source, &quot;&lt;CALL|ALIAS&quot;, 6) yield path where none(n in nodes(path) where (n.CLASSNAME =~ &quot;javax.management.*&quot; or n.CLASSNAME =~ &quot;com.alibaba.fastjson.*&quot; ))</span><br><span class="line">return * limit 10</span><br></pre></td></tr></table></figure>
<h4 id="web层次找可能的未授权"><a href="#web层次找可能的未授权" class="headerlink" title="web层次找可能的未授权"></a>web层次找可能的未授权</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (source:Method) WHERE source.NAME in [&quot;doGet&quot;,&quot;doPost&quot;]</span><br><span class="line">MATCH (sink:Method&#123;NAME:&quot;doUploadBrithdayCard&quot;&#125;)&lt;-[:CALL]-(m1:Method)</span><br><span class="line">CALL apoc.algo.allSimplePaths(m1, source ,&quot;&lt;CALL|ALIAS&quot;, 8) yield path</span><br><span class="line">RETURN * limit 20</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>它这个工具找到其实挺全的，但是容易跑偏，毕竟没有考虑参数传递，只考虑了方法调用，所以我们最好一段一段去找，当成一个思路扩展和日常学习的辅助工具还是不错的</p>
<h2 id="codeQL使用"><a href="#codeQL使用" class="headerlink" title="codeQL使用"></a>codeQL使用</h2><p>CodeQL支持进行漏洞挖掘的语言包括：C/C++、C#、Go、Java、JavaScript、Python、Ruby。其针对这些不同的语言有着不同的规则编写规范，所以相比tabby,CodeQL使用起来也更加复杂</p>
<h3 id="使用前的准备"><a href="#使用前的准备" class="headerlink" title="使用前的准备"></a>使用前的准备</h3><h4 id="创建codeql数据库"><a href="#创建codeql数据库" class="headerlink" title="创建codeql数据库"></a>创建codeql数据库</h4><p>在使用 CodeQL 分析代码之前，需要创建一个 CodeQL 数据库</p>
<p>这条命令需要在需要审计的源代码目录中使用,如果要审计jar包,需要把jar包解压成项目文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">codeql database create ./xxx_db --language=xxx</span><br><span class="line"><span class="comment">#java需要lib库的，要加command参数运行一下mvn安装依赖</span></span><br><span class="line">CodeQL database create  quartz_db --language=<span class="string">&quot;java&quot;</span>  --<span class="built_in">command</span>=<span class="string">&quot;mvn clean install --file pom.xml -Dmaven.test.skip=true&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#对与单个jar/war文件使用CodeQLpy生成数据库</span></span><br><span class="line">python3 main.py -t xxx.jar -c</span><br><span class="line">CodeQL database create  quartz_db --language=<span class="string">&quot;java&quot;</span>  --<span class="built_in">command</span>=<span class="string">&quot;run.cmd&quot;</span> --overwrite</span><br></pre></td></tr></table></figure>
<h4 id="使用vscode插件分析数据库"><a href="#使用vscode插件分析数据库" class="headerlink" title="使用vscode插件分析数据库"></a>使用vscode插件分析数据库</h4><p>vscode打开<code>ql\java\ql\examples\snippets</code>目录，vscode插件选中生成数据库并选择java语言<br>随后编写脚本,点击 运行，就可以查看查找结果了</p>
<p>此外还支持命令行的形式运行<br>codeql database analyze ./quartz_db  –format=csv –output=result.csv<br>codeql database analyze ./quartz_db ./CodeQL/ql/java/ql/examples/demo –format=csv –output=result.csv</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">类型</span><br><span class="line">RefType       Class或Interface</span><br><span class="line"></span><br><span class="line">hasQualifiedName(&quot;javax.naming&quot;, &quot;Context&quot;) 类的名字叫javax.naming.Context</span><br><span class="line">getACallable() 获取所有可以调用方法(其中包括构造方法)</span><br><span class="line">getAMember() 获取所有成员，其中包括调用方法，字段和内部类</span><br><span class="line">getAField() 获取所有字段</span><br><span class="line">getAMethod() 获取所有方法</span><br><span class="line">getASupertype() 获取父类</span><br><span class="line">getAnAncestor() 获取所有的父类相当于递归的getASupertype*()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">method</span><br><span class="line"></span><br><span class="line">this.hasName(&quot;parse&quot;)   名字叫parse</span><br><span class="line">getNumberOfParameters() 参数数量</span><br><span class="line">getParameter(0)         获取第一个形参</span><br><span class="line">fromSource()            来自源代码，而不是从其他地方（如库或编译生成的代码）</span><br><span class="line">getDeclaringType()      获取的是当前方法所属class的名称</span><br><span class="line"></span><br><span class="line">简单地说， Callable是可以被调用的东西， Call是调用Callable的东西。他俩都属于method</span><br><span class="line">    Callable  可以调用方法</span><br><span class="line">    polyCalls(Callable target) 一个Callable 是否调用了另外的Callable，这里面包含了类似虚函数的调用</span><br><span class="line">    hasName(name) 可以对方法名进行限制</span><br><span class="line"></span><br><span class="line">    Call</span><br><span class="line">    getCallee() 返回函数声明的位置，及转换成method</span><br><span class="line">    getCaller() 返回调用这个函数的函数位置</span><br></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>收集了一些QL</p>
<h5 id="寻找特定类或方法"><a href="#寻找特定类或方法" class="headerlink" title="寻找特定类或方法"></a>寻找特定类或方法</h5><p>寻找public构造方法且该构造方法只有一个String类型的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java <span class="comment">//导入codeql的java依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//where部分的查询条件如果过长，会显得很乱。CodeQL提供一种机制可以让你把很长的查询语句封装成函数；这个函数，就叫谓词</span></span><br><span class="line"><span class="function">predicate <span class="title">isparam</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    method.getNumberOfParameters() = <span class="number">1</span> </span><br><span class="line">    and</span><br><span class="line">    method.getParameter(<span class="number">0</span>).getType().getName() = <span class="string">&quot;String&quot;</span> </span><br><span class="line">&#125;<span class="comment">//第一个参数类型是String</span></span><br><span class="line"></span><br><span class="line">from Constructor c <span class="comment">//c是一个构造方法</span></span><br><span class="line"><span class="comment">//获取声明该构造方法的类类型， 检查这个构造方法是否是公共的</span></span><br><span class="line">where c.getDeclaringType().getAMethod().isPublic() </span><br><span class="line"><span class="function">and <span class="title">isparam</span><span class="params">(c)</span> </span></span><br><span class="line"><span class="function">and c.<span class="title">fromSource</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">and c.<span class="title">getName</span><span class="params">()</span> !</span>= <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">select c <span class="comment">//输出查找结果</span></span><br></pre></td></tr></table></figure>
<h5 id="寻找Lookup调用getter-setter方法，及证明jndi"><a href="#寻找Lookup调用getter-setter方法，及证明jndi" class="headerlink" title="寻找Lookup调用getter,setter方法，及证明jndi"></a>寻找Lookup调用getter,setter方法，及证明jndi</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookupMethod</span> <span class="keyword">extends</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">  LookupMethod() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getCallee().getDeclaringType().getASupertype*().hasQualifiedName(<span class="string">&quot;javax.naming&quot;</span>, <span class="string">&quot;Context&quot;</span>) and</span><br><span class="line">    <span class="keyword">this</span>.getCallee().hasName(<span class="string">&quot;lookup&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetterCallable</span> <span class="keyword">extends</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">  GetterCallable() &#123;</span><br><span class="line">    getName().matches(<span class="string">&quot;get%&quot;</span>) <span class="function">and</span></span><br><span class="line"><span class="function">    <span class="title">hasNoParameters</span><span class="params">()</span> and</span></span><br><span class="line"><span class="function">    <span class="title">getName</span><span class="params">()</span>.<span class="title">length</span><span class="params">()</span> &gt; 3</span></span><br><span class="line"><span class="function">    or</span></span><br><span class="line"><span class="function">    <span class="title">getName</span><span class="params">()</span>.<span class="title">matches</span><span class="params">(<span class="string">&quot;set%&quot;</span>)</span> and</span></span><br><span class="line"><span class="function">    <span class="title">getNumberOfParameters</span><span class="params">()</span> </span>= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">query predicate <span class="title">edges</span><span class="params">(Callable a, Callable b)</span> </span>&#123; a.polyCalls(b) &#125;</span><br><span class="line"></span><br><span class="line">from LookupMethod endcall, GetterCallable entryPoint, Callable endCallAble</span><br><span class="line">where</span><br><span class="line">  endcall.getCallee() = endCallAble and</span><br><span class="line">  edges+(entryPoint, endCallAble)</span><br><span class="line">select endcall.getCaller(), entryPoint, endcall.getCaller(), <span class="string">&quot;Geter jndi&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="spring框架中MyBatis-SQL注入"><a href="#spring框架中MyBatis-SQL注入" class="headerlink" title="spring框架中MyBatis SQL注入"></a>spring框架中MyBatis SQL注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java</span><br><span class="line"><span class="keyword">import</span> DataFlow2::PathGraph</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.DataFlow</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.FlowSources</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.TaintTracking2</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllControllerMethod</span> <span class="keyword">extends</span> <span class="title">Method</span></span>&#123;  <span class="comment">//获取所有Controller中的方法</span></span><br><span class="line">    AllControllerMethod()&#123;</span><br><span class="line">        exists(</span><br><span class="line">            RefType rt |</span><br><span class="line">            rt.getName().indexOf(<span class="string">&quot;Controller&quot;</span>)&gt;<span class="number">0</span> and <span class="comment">//万一不叫control就寄了</span></span><br><span class="line">            <span class="keyword">this</span> = rt.getACallable()</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBatisMapperXmlFile</span> <span class="keyword">extends</span> <span class="title">XmlFile</span> </span>&#123; <span class="comment">//获取MyBatis MapperXML 文件</span></span><br><span class="line">    MyBatisMapperXmlFile()&#123;</span><br><span class="line">    count( XmlElement e|e = <span class="keyword">this</span>.getAChild()) = <span class="number">1</span> and</span><br><span class="line">    <span class="keyword">this</span>.getAChild().getName()=<span class="string">&quot;mapper&quot;</span><span class="comment">//mapper的子标签</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBatisMapperXmlElement</span> <span class="keyword">extends</span> <span class="title">XmlElement</span> </span>&#123;<span class="comment">//获取到标签中的值</span></span><br><span class="line">    MyBatisMapperXmlElement()&#123;</span><br><span class="line">        <span class="keyword">this</span>.getFile() <span class="keyword">instanceof</span> MyBatisMapperXmlFile</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        result = <span class="keyword">this</span>.getAttribute(<span class="string">&quot;id&quot;</span>).getValue() <span class="comment">//获取id属性的值,代表的是方法名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        result = <span class="keyword">this</span>.getAChild*().allCharactersString().trim() <span class="comment">//加个*是递归的意思，递归获取元素中的值(大量重复)，父标签会包含子标签的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBatisMapperVulMethod</span> <span class="keyword">extends</span> <span class="title">Method</span></span>&#123;  <span class="comment">//寻找 $&#123;&#125;对应的方法</span></span><br><span class="line">    MyBatisMapperVulMethod()&#123;</span><br><span class="line">        exists(MyBatisMapperXmlElement mmxe| </span><br><span class="line">            mmxe.getValue().indexOf(<span class="string">&quot;$&#123;&quot;</span>)&gt;<span class="number">0</span> and <span class="comment">//找到$&#123;&#125;的标签</span></span><br><span class="line">            <span class="keyword">this</span>.hasName(mmxe.getId()) and <span class="comment">//方法名相同</span></span><br><span class="line">            <span class="keyword">this</span>.getDeclaringType().getASubtype*().getQualifiedName() =  <span class="comment">//递归获取父类名 是否和xml中namespace相等，则证明类名相同</span></span><br><span class="line">            mmxe.getFile().getAChild().getAttribute(<span class="string">&quot;namespace&quot;</span>).getValue()</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据流分析</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTaintTrackingConfiguration</span> <span class="keyword">extends</span> <span class="title">TaintTracking2</span>::<span class="title">Configuration</span></span>&#123;</span><br><span class="line">    MyTaintTrackingConfiguration()&#123;</span><br><span class="line">        <span class="keyword">this</span> = <span class="string">&quot;MyTaintTrackingConfiguration&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">override predicate <span class="title">isSource</span><span class="params">(DataFlow::Node source)</span> </span>&#123;</span><br><span class="line">        <span class="function">source <span class="keyword">instanceof</span> RemoteFlowSource or</span></span><br><span class="line"><span class="function">        <span class="title">exists</span><span class="params">(Method m |</span></span></span><br><span class="line"><span class="params"><span class="function">            m <span class="keyword">instanceof</span> AllControllerMethod and</span></span></span><br><span class="line"><span class="params"><span class="function">            source.asParameter()</span> </span>= m.getAParameter()  <span class="comment">//类名，参数都相等，将Controller的方法参数当作source</span></span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">override predicate <span class="title">isSink</span><span class="params">(DataFlow::Node sink)</span> </span>&#123;   <span class="comment">//sink点为使用了 $&#123;...&#125; 的XML文件对应的方法的方法调用中的任意一个参数</span></span><br><span class="line">        exists(MethodCall call, MyBatisMapperXmlElement mmxe, string</span><br><span class="line">            unsafeExpression |</span><br><span class="line">            call.getMethod() <span class="keyword">instanceof</span> MyBatisMapperVulMethod and</span><br><span class="line">            unsafeExpression = mmxe.getValue().regexpFind(<span class="string">&quot;(\\$)\\&#123;[^\\&#125;]*\\&#125;&quot;</span>,<span class="comment">//sink处方法调用的参数一定得是使用了$&#123;...&#125;的</span></span><br><span class="line">            _, _) and</span><br><span class="line">            (sink.asExpr().toString() = unsafeExpression.substring(<span class="number">2</span>,</span><br><span class="line">            unsafeExpression.length()-<span class="number">1</span>) or</span><br><span class="line">            <span class="comment">//形如criterion.condition这种参数，应以&quot;.&quot;作为分隔符，分别判断</span></span><br><span class="line">            sink.asExpr().toString() = unsafeExpression.substring(<span class="number">2</span>,</span><br><span class="line">            unsafeExpression.length()-<span class="number">1</span>).splitAt(<span class="string">&quot;.&quot;</span>)) and</span><br><span class="line">            sink.asExpr() = call.getAnArgument()</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from MyTaintTrackingConfiguration config, DataFlow2::PathNode source,DataFlow2::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(),source, sink, <span class="string">&quot;sqlInject!&quot;</span></span><br></pre></td></tr></table></figure>

<p>官方的sql注入查询的ql，codeql-main\java\ql\src\experimental\Security\CWE\CWE-089\MyBatisMapperXmlSqlInjection.ql<br>可以看官方文档，<code>https://codeql.github.com/codeql-query-help/go/</code></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>codeql在找java链子方面功能要比tabby强大，tabby只能按照开发者设置规则来找链子，但是codeql可以自己设计规则，如找固定参数类型的方法，或者找实现某个接口的类，找符合某种自定义规则的方法</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/08/20/server/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/">应急响应</a>
            
            
            <a class="next" rel="next" href="/2024/07/21/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/">数据库提权</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mayylu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>